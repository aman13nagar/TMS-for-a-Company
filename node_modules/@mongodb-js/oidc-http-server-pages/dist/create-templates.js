"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateCompressedTemplates = exports.generateTemplates = void 0;
const server_1 = require("react-dom/server");
const emotion_1 = require("@leafygreen-ui/emotion");
const pages_source_1 = require("./pages-source");
const react_1 = __importDefault(require("react"));
const zlib_1 = require("zlib");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const types_1 = require("./types");
function* allSubsets(array) {
    if (array.length === 0) {
        yield [];
        return;
    }
    const first = array[0];
    for (const slicedSubset of allSubsets(array.slice(1))) {
        yield [first, ...slicedSubset];
        yield slicedSubset;
    }
}
function placeholder(prop) {
    return `{{prop:${prop}}}`;
}
function getPageTemplates({ Component, parameters, }) {
    const templates = [];
    for (const paramsSubset of allSubsets(parameters)) {
        const propsObject = Object.fromEntries(paramsSubset.map((prop) => [prop, placeholder(prop)]));
        const markup = (0, emotion_1.renderStylesToString)((0, server_1.renderToStaticMarkup)(react_1.default.createElement(Component, propsObject)));
        templates.push({
            parameters: propsObject,
            html: markup,
        });
    }
    return templates;
}
function generateTemplates(pages) {
    const templates = {};
    for (const pageName of Object.keys(pages)) {
        const { Component, parameters } = pages[pageName];
        const PageTemplates = getPageTemplates({
            Component,
            parameters,
        });
        templates[pageName] = PageTemplates;
    }
    return templates;
}
exports.generateTemplates = generateTemplates;
function generateGzip(data) {
    const buffer = (0, zlib_1.gzipSync)(data);
    (0, fs_1.writeFileSync)(path_1.default.join(__dirname, 'templates.gz'), buffer, 'binary');
}
function generateJS(data) {
    const buffer = (0, zlib_1.brotliCompressSync)(data, {
        params: {
            [zlib_1.constants.BROTLI_PARAM_MODE]: zlib_1.constants.BROTLI_MODE_TEXT,
            [zlib_1.constants.BROTLI_PARAM_QUALITY]: zlib_1.constants.BROTLI_MAX_QUALITY,
        },
    });
    (0, fs_1.writeFileSync)(path_1.default.join(__dirname, 'get-templates.js'), `
    const { brotliDecompressSync } = require('zlib');
    function getTemplates() {
      const buffer = brotliDecompressSync(
        Buffer.from(
          '${buffer.toString('base64')}', 
          'base64'
        )
      );
      return JSON.parse(buffer.toString());
    }
    module.exports = getTemplates;
  `);
}
function generateCompressedTemplates(pages) {
    const templates = JSON.stringify(generateTemplates(pages));
    generateGzip(templates);
    generateJS(templates);
}
exports.generateCompressedTemplates = generateCompressedTemplates;
if (require.main === module) {
    generateCompressedTemplates({
        [types_1.HttpServerPage.OIDCErrorPage]: {
            Component: pages_source_1.OIDCErrorPage,
            parameters: [
                'error',
                'errorDescription',
                'errorURI',
                'productDocsLink',
                'productName',
            ],
        },
        [types_1.HttpServerPage.OIDCAcceptedPage]: {
            Component: pages_source_1.OIDCAcceptedPage,
            parameters: ['productDocsLink', 'productName'],
        },
        [types_1.HttpServerPage.OIDCNotFoundPage]: {
            Component: pages_source_1.OIDCNotFoundPage,
            parameters: ['productDocsLink', 'productName'],
        },
    });
}
//# sourceMappingURL=create-templates.js.map