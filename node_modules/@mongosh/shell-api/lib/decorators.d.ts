import type { ReplPlatform } from '@mongosh/service-provider-core';
import type { Mongo, ShellInstanceState } from '.';
import type { Topologies } from './enums';
import { asPrintable, shellApiType } from './enums';
export interface Namespace {
    db: string;
    collection: string;
}
export interface ShellResultSourceInformation {
    namespace: Namespace;
}
export interface ShellResult {
    rawValue: any;
    printable: any;
    type: string | null;
    source?: ShellResultSourceInformation;
}
export declare abstract class ShellApiClass {
    help: any;
    abstract get _instanceState(): ShellInstanceState;
    get [shellApiType](): string;
    set [shellApiType](value: string);
    [asPrintable](): any;
}
export declare abstract class ShellApiWithMongoClass extends ShellApiClass {
    abstract get _mongo(): Mongo;
    get _instanceState(): ShellInstanceState;
}
export declare abstract class ShellApiValueClass extends ShellApiClass {
    get _mongo(): never;
    get _instanceState(): never;
}
export declare function getShellApiType(rawValue: any): string | null;
export declare function toShellResult(rawValue: any): Promise<ShellResult>;
export interface ShellCommandAutocompleteParameters {
    getCollectionCompletionsForCurrentDb: (collName: string) => string[] | Promise<string[]>;
    getDatabaseCompletions: (dbName: string) => string[] | Promise<string[]>;
}
export type ShellCommandCompleter = (params: ShellCommandAutocompleteParameters, args: string[]) => Promise<string[] | undefined>;
export interface TypeSignature {
    type: string;
    serverVersions?: [string, string];
    apiVersions?: [number, number];
    topologies?: Topologies[];
    returnsPromise?: boolean;
    deprecated?: boolean;
    returnType?: string | TypeSignature;
    attributes?: {
        [key: string]: TypeSignature;
    };
    isDirectShellCommand?: boolean;
    acceptsRawInput?: boolean;
    shellCommandCompleter?: ShellCommandCompleter;
}
interface Signatures {
    [key: string]: TypeSignature;
}
declare const signatures: Signatures;
export { signatures };
export declare const toIgnore: string[];
export declare function shellApiClassDefault<T extends {
    prototype: any;
}>(constructor: T, context: ClassDecoratorContext): void;
export declare function shellApiClassNoHelp<T extends {
    prototype: any;
}>(constructor: T, context: ClassDecoratorContext): void;
export declare function serverVersions(serverVersions: [string, string]): <T extends Function>(value: T, context: ClassMethodDecoratorContext) => T & {
    serverVersions: [string, string];
};
export declare function apiVersions(versionArray: [] | [number] | [number, number]): <T extends Function>(value: T, context: ClassMethodDecoratorContext) => T & {
    apiVersions: [number, number];
};
export declare function deprecated<T extends Function>(value: T, context: ClassMethodDecoratorContext): T & {
    deprecated: true;
};
export declare function topologies(topologies: Topologies[]): <T extends Function>(value: T, context: ClassMethodDecoratorContext) => T & {
    topologies: Topologies[];
};
export declare const nonAsyncFunctionsReturningPromises: string[];
export declare function returnsPromise<This, Args extends any[], Return>(originalFunction: (this: This, ...args: Args) => Promise<Return>, context: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Promise<Return>>): ((this: This, ...args: Args) => Promise<Return>) & {
    returnsPromise: true;
};
export declare function directShellCommand<T extends Function>(value: T, context: ClassMethodDecoratorContext): T & {
    isDirectShellCommand: true;
};
export declare function shellCommandCompleter(shellCommandCompleter: ShellCommandCompleter): <T extends Function>(value: T, context: ClassMethodDecoratorContext) => T & {
    shellCommandCompleter: ShellCommandCompleter;
};
export declare function returnType(returnType: string): <T extends Function>(value: T, context: ClassMethodDecoratorContext) => T & {
    returnType: string;
};
export declare function classDeprecated<T extends {
    prototype: any;
}>(constructor: T, context: ClassDecoratorContext): void;
export declare function platforms(platforms: ReplPlatform[]): <T extends Function>(value: T, context: ClassMethodDecoratorContext) => T & {
    platforms: ReplPlatform[];
};
export declare function classPlatforms(platformsArray: ReplPlatform[]): Function;
export declare function addSourceToResults<T extends {
    prototype: any;
}>(constructor: T, context: ClassDecoratorContext): void;
