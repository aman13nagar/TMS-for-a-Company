"use strict";
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("./decorators");
const helpers_1 = require("./helpers");
const enums_1 = require("./enums");
const result_1 = require("./result");
const history_1 = require("@mongosh/history");
const semver_1 = __importDefault(require("semver"));
let Shard = (() => {
    let _classDecorators = [decorators_1.shellApiClassDefault];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _classSuper = decorators_1.ShellApiWithMongoClass;
    let _instanceExtraInitializers = [];
    let _enableSharding_decorators;
    let _commitReshardCollection_decorators;
    let _abortReshardCollection_decorators;
    let _shardCollection_decorators;
    let _reshardCollection_decorators;
    let _status_decorators;
    let _addShard_decorators;
    let _addShardToZone_decorators;
    let _addShardTag_decorators;
    let _updateZoneKeyRange_decorators;
    let _addTagRange_decorators;
    let _removeRangeFromZone_decorators;
    let _removeTagRange_decorators;
    let _removeShardFromZone_decorators;
    let _removeShardTag_decorators;
    let _enableAutoSplit_decorators;
    let _disableAutoSplit_decorators;
    let _splitAt_decorators;
    let _splitFind_decorators;
    let _moveChunk_decorators;
    let _balancerCollectionStatus_decorators;
    let _enableBalancing_decorators;
    let _disableBalancing_decorators;
    let _getBalancerState_decorators;
    let _isBalancerRunning_decorators;
    let _startBalancer_decorators;
    let _stopBalancer_decorators;
    let _setBalancerState_decorators;
    let _getShardedDataDistribution_decorators;
    let _startAutoMerger_decorators;
    let _stopAutoMerger_decorators;
    let _isAutoMergerEnabled_decorators;
    let _disableAutoMerger_decorators;
    let _enableAutoMerger_decorators;
    let _checkMetadataConsistency_decorators;
    var Shard = _classThis = class extends _classSuper {
        constructor(database) {
            super();
            this._database = (__runInitializers(this, _instanceExtraInitializers), void 0);
            this._database = database;
        }
        get _mongo() {
            return this._database._mongo;
        }
        [enums_1.asPrintable]() {
            return `Shard class connected to ${(0, history_1.redactURICredentials)(this._database._mongo._uri)} via db ${this._database._name}`;
        }
        _emitShardApiCall(methodName, methodArguments = {}) {
            this._database._mongo._instanceState.emitApiCallWithArgs({
                method: methodName,
                class: 'Shard',
                arguments: methodArguments,
            });
        }
        async enableSharding(database, primaryShard) {
            (0, helpers_1.assertArgsDefinedType)([database, primaryShard], ['string', [undefined, 'string']], 'Shard.enableSharding');
            this._emitShardApiCall('enableSharding', { database, primaryShard });
            const cmd = {
                enableSharding: database,
            };
            if (primaryShard !== undefined) {
                cmd.primaryShard = primaryShard;
            }
            try {
                return await this._database._runAdminCommand(cmd);
            }
            catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                    error.message = `${error.message}. Are you connected to mongos?`;
                }
                throw error;
            }
        }
        async commitReshardCollection(namespace) {
            (0, helpers_1.assertArgsDefinedType)([namespace], ['string'], 'Shard.commitReshardCollection');
            this._emitShardApiCall('commitReshardCollection', { namespace });
            return await this._database._runAdminCommand({
                commitReshardCollection: namespace,
            });
        }
        async abortReshardCollection(namespace) {
            (0, helpers_1.assertArgsDefinedType)([namespace], ['string'], 'Shard.abortReshardCollection');
            this._emitShardApiCall('abortReshardCollection', { namespace });
            return await this._database._runAdminCommand({
                abortReshardCollection: namespace,
            });
        }
        async shardCollection(namespace, key, unique, options) {
            return await this._runShardCollection('shardCollection', namespace, key, unique, options);
        }
        async reshardCollection(namespace, key, unique, options) {
            return await this._runShardCollection('reshardCollection', namespace, key, unique, options);
        }
        async _runShardCollection(command, namespace, key, unique, options) {
            (0, helpers_1.assertArgsDefinedType)([namespace, key, unique, options], [
                'string',
                'object',
                [undefined, 'boolean', 'object'],
                [undefined, 'object'],
            ], `Shard.${command}`);
            this._emitShardApiCall(command, { namespace, key, unique, options });
            if (typeof unique === 'object' && unique !== null) {
                options = unique;
                unique = undefined;
            }
            const cmd = {
                [command]: namespace,
                key: key,
            };
            if (unique !== undefined) {
                cmd.unique = unique;
            }
            try {
                return await this._database._runAdminCommand({ ...cmd, ...options });
            }
            catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                    error.message = `${error.message}. Are you connected to mongos?`;
                }
                throw error;
            }
        }
        async status(verbose = false, configDB) {
            const result = await (0, helpers_1.getPrintableShardStatus)(configDB !== null && configDB !== void 0 ? configDB : (await (0, helpers_1.getConfigDB)(this._database)), verbose);
            return new result_1.CommandResult('StatsResult', result);
        }
        async addShard(url) {
            (0, helpers_1.assertArgsDefinedType)([url], ['string'], 'Shard.addShard');
            await (0, helpers_1.getConfigDB)(this._database);
            this._emitShardApiCall('addShard', { url });
            return this._database._runAdminCommand({
                addShard: url,
            });
        }
        async addShardToZone(shard, zone) {
            (0, helpers_1.assertArgsDefinedType)([shard, zone], ['string', 'string'], 'Shard.addShardToZone');
            this._emitShardApiCall('addShardToZone', { shard, zone });
            await (0, helpers_1.getConfigDB)(this._database);
            return this._database._runAdminCommand({
                addShardToZone: shard,
                zone: zone,
            });
        }
        async addShardTag(shard, tag) {
            (0, helpers_1.assertArgsDefinedType)([shard, tag], ['string', 'string'], 'Shard.addShardTag');
            this._emitShardApiCall('addShardTag', { shard, tag });
            try {
                return await this.addShardToZone(shard, tag);
            }
            catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                    error.message = `${error.message}. This method aliases to addShardToZone which exists only for server versions > 3.4.`;
                }
                throw error;
            }
        }
        async updateZoneKeyRange(namespace, min, max, zone) {
            (0, helpers_1.assertArgsDefinedType)([namespace, min, max, zone], ['string', 'object', 'object', true], 'Shard.updateZoneKeyRange');
            this._emitShardApiCall('updateZoneKeyRange', { namespace, min, max, zone });
            await (0, helpers_1.getConfigDB)(this._database);
            return await this._database._runAdminCommand({
                updateZoneKeyRange: namespace,
                min,
                max,
                zone,
            });
        }
        async addTagRange(namespace, min, max, zone) {
            (0, helpers_1.assertArgsDefinedType)([namespace, min, max, zone], ['string', 'object', 'object', true], 'Shard.addTagRange');
            this._emitShardApiCall('addTagRange', { namespace, min, max, zone });
            try {
                return await this.updateZoneKeyRange(namespace, min, max, zone);
            }
            catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                    error.message = `${error.message}. This method aliases to updateZoneKeyRange which exists only for server versions > 3.4.`;
                }
                throw error;
            }
        }
        async removeRangeFromZone(ns, min, max) {
            (0, helpers_1.assertArgsDefinedType)([ns, min, max], ['string', 'object', 'object'], 'Shard.removeRangeFromZone');
            this._emitShardApiCall('removeRangeFromZone', { ns, min, max });
            return this.updateZoneKeyRange(ns, min, max, null);
        }
        async removeTagRange(ns, min, max) {
            (0, helpers_1.assertArgsDefinedType)([ns, min, max], ['string', 'object', 'object'], 'Shard.removeTagRange');
            this._emitShardApiCall('removeTagRange', { ns, min, max });
            try {
                return await this.updateZoneKeyRange(ns, min, max, null);
            }
            catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                    error.message = `${error.message}. This method aliases to updateZoneKeyRange which exists only for server versions > 3.4.`;
                }
                throw error;
            }
        }
        async removeShardFromZone(shard, zone) {
            (0, helpers_1.assertArgsDefinedType)([shard, zone], ['string', 'string'], 'Shard.removeShardFromZone');
            this._emitShardApiCall('removeShardFromZone', { shard, zone });
            await (0, helpers_1.getConfigDB)(this._database);
            return await this._database._runAdminCommand({
                removeShardFromZone: shard,
                zone: zone,
            });
        }
        async removeShardTag(shard, tag) {
            (0, helpers_1.assertArgsDefinedType)([shard, tag], ['string', 'string'], 'Shard.removeShardTag');
            this._emitShardApiCall('removeTagRange', { shard, tag });
            try {
                return await this.removeShardFromZone(shard, tag);
            }
            catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                    error.message = `${error.message}. This method aliases to removeShardFromZone which exists only for server versions > 3.4.`;
                }
                throw error;
            }
        }
        async enableAutoSplit() {
            var _a;
            const connectionInfo = await this._instanceState.fetchConnectionInfo();
            if (((_a = connectionInfo === null || connectionInfo === void 0 ? void 0 : connectionInfo.buildInfo) === null || _a === void 0 ? void 0 : _a.version) &&
                semver_1.default.gte(connectionInfo.buildInfo.version, '6.0.3')) {
                await this._instanceState.printDeprecationWarning('Starting in MongoDB 6.0.3, automatic chunk splitting is not performed. This is because of balancing policy improvements. Auto-splitting commands still exist, but do not perform an operation. For details, see Balancing Policy Changes: https://www.mongodb.com/docs/manual/release-notes/6.0/#balancing-policy-changes\n');
            }
            this._emitShardApiCall('enableAutoSplit', {});
            const config = await (0, helpers_1.getConfigDB)(this._database);
            return (await config
                .getCollection('settings')
                .updateOne({ _id: 'autosplit' }, { $set: { enabled: true } }, { upsert: true, writeConcern: { w: 'majority', wtimeout: 30000 } }));
        }
        async disableAutoSplit() {
            var _a;
            const connectionInfo = await this._instanceState.fetchConnectionInfo();
            if (((_a = connectionInfo === null || connectionInfo === void 0 ? void 0 : connectionInfo.buildInfo) === null || _a === void 0 ? void 0 : _a.version) &&
                semver_1.default.gte(connectionInfo.buildInfo.version, '6.0.3')) {
                await this._instanceState.printDeprecationWarning('Starting in MongoDB 6.0.3, automatic chunk splitting is not performed. This is because of balancing policy improvements. Auto-splitting commands still exist, but do not perform an operation. For details, see Balancing Policy Changes: https://www.mongodb.com/docs/manual/release-notes/6.0/#balancing-policy-changes\n');
            }
            this._emitShardApiCall('disableAutoSplit', {});
            const config = await (0, helpers_1.getConfigDB)(this._database);
            return (await config
                .getCollection('settings')
                .updateOne({ _id: 'autosplit' }, { $set: { enabled: false } }, { upsert: true, writeConcern: { w: 'majority', wtimeout: 30000 } }));
        }
        async splitAt(ns, query) {
            (0, helpers_1.assertArgsDefinedType)([ns, query], ['string', 'object'], 'Shard.splitAt');
            this._emitShardApiCall('splitAt', { ns, query });
            return this._database._runAdminCommand({
                split: ns,
                middle: query,
            });
        }
        async splitFind(ns, query) {
            (0, helpers_1.assertArgsDefinedType)([ns, query], ['string', 'object'], 'Shard.splitFind');
            this._emitShardApiCall('splitFind', { ns, query });
            return this._database._runAdminCommand({
                split: ns,
                find: query,
            });
        }
        async moveChunk(ns, query, destination) {
            (0, helpers_1.assertArgsDefinedType)([ns, query, destination], ['string', 'object', 'string'], 'Shard.moveChunk');
            this._emitShardApiCall('moveChunk', { ns, query, destination });
            return this._database._runAdminCommand({
                moveChunk: ns,
                find: query,
                to: destination,
            });
        }
        async balancerCollectionStatus(ns) {
            (0, helpers_1.assertArgsDefinedType)([ns], ['string'], 'Shard.balancerCollectionStatus');
            this._emitShardApiCall('balancerCollectionStatus', { ns });
            return this._database._runAdminCommand({
                balancerCollectionStatus: ns,
            });
        }
        async enableBalancing(ns) {
            (0, helpers_1.assertArgsDefinedType)([ns], ['string'], 'Shard.enableBalancing');
            this._emitShardApiCall('enableBalancing', { ns });
            const config = await (0, helpers_1.getConfigDB)(this._database);
            return (await config
                .getCollection('collections')
                .updateOne({ _id: ns }, { $set: { noBalance: false } }, { writeConcern: { w: 'majority', wtimeout: 60000 } }));
        }
        async disableBalancing(ns) {
            (0, helpers_1.assertArgsDefinedType)([ns], ['string'], 'Shard.disableBalancing');
            this._emitShardApiCall('disableBalancing', { ns });
            const config = await (0, helpers_1.getConfigDB)(this._database);
            return (await config
                .getCollection('collections')
                .updateOne({ _id: ns }, { $set: { noBalance: true } }, { writeConcern: { w: 'majority', wtimeout: 60000 } }));
        }
        async getBalancerState() {
            this._emitShardApiCall('getBalancerState', {});
            const config = await (0, helpers_1.getConfigDB)(this._database);
            const doc = await config
                .getCollection('settings')
                .findOne({ _id: 'balancer' });
            if (doc === null || doc === undefined) {
                return true;
            }
            return !doc.stopped;
        }
        async isBalancerRunning() {
            this._emitShardApiCall('isBalancerRunning', {});
            await (0, helpers_1.getConfigDB)(this._database);
            return this._database._runAdminCommand({
                balancerStatus: 1,
            });
        }
        async startBalancer(timeout = 60000) {
            (0, helpers_1.assertArgsDefinedType)([timeout], ['number'], 'Shard.startBalancer');
            this._emitShardApiCall('startBalancer', { timeout });
            return this._database._runAdminCommand({
                balancerStart: 1,
                maxTimeMS: timeout,
            });
        }
        async stopBalancer(timeout = 60000) {
            (0, helpers_1.assertArgsDefinedType)([timeout], ['number'], 'Shard.stopBalancer');
            this._emitShardApiCall('stopBalancer', { timeout });
            return this._database._runAdminCommand({
                balancerStop: 1,
                maxTimeMS: timeout,
            });
        }
        async setBalancerState(state) {
            (0, helpers_1.assertArgsDefinedType)([state], ['boolean'], 'Shard.setBalancerState');
            this._emitShardApiCall('setBalancerState', { state });
            if (state) {
                return this.startBalancer();
            }
            return this.stopBalancer();
        }
        async getShardedDataDistribution(options = {}) {
            var _a;
            this._emitShardApiCall('getShardedDataDistribution', {});
            const cursor = await this._database
                .getSiblingDB('admin')
                .aggregate([{ $shardedDataDistribution: options }]);
            try {
                await cursor.hasNext();
            }
            catch (err) {
                if (((_a = err.code) === null || _a === void 0 ? void 0 : _a.valueOf()) === 40324) {
                    err.message = `sh.getShardedDataDistribution only works on mongos and MongoDB server versions greater than 6.0.3 [Original Error: ${err.message}]`;
                }
                throw err;
            }
            return cursor;
        }
        async startAutoMerger() {
            this._emitShardApiCall('startAutoMerger', {});
            const config = await (0, helpers_1.getConfigDB)(this._database);
            return (await config
                .getCollection('settings')
                .updateOne({ _id: 'automerge' }, { $set: { enabled: true } }, { upsert: true, writeConcern: { w: 'majority', wtimeout: 30000 } }));
        }
        async stopAutoMerger() {
            this._emitShardApiCall('stopAutoMerger', {});
            const config = await (0, helpers_1.getConfigDB)(this._database);
            return (await config
                .getCollection('settings')
                .updateOne({ _id: 'automerge' }, { $set: { enabled: false } }, { upsert: true, writeConcern: { w: 'majority', wtimeout: 30000 } }));
        }
        async isAutoMergerEnabled() {
            this._emitShardApiCall('isAutoMergerEnabled', {});
            const config = await (0, helpers_1.getConfigDB)(this._database);
            const doc = await config
                .getCollection('settings')
                .findOne({ _id: 'automerge' });
            if (doc === null || doc === undefined) {
                return true;
            }
            return doc.enabled;
        }
        async disableAutoMerger(ns) {
            (0, helpers_1.assertArgsDefinedType)([ns], ['string'], 'Shard.disableAutoMerger');
            this._emitShardApiCall('disableAutoMerger', { ns });
            const config = await (0, helpers_1.getConfigDB)(this._database);
            return (await config
                .getCollection('collections')
                .updateOne({ _id: ns }, { $set: { enableAutoMerge: false } }, { writeConcern: { w: 'majority', wtimeout: 60000 } }));
        }
        async enableAutoMerger(ns) {
            (0, helpers_1.assertArgsDefinedType)([ns], ['string'], 'Shard.enableAutoMerger');
            this._emitShardApiCall('enableAutoMerger', { ns });
            const config = await (0, helpers_1.getConfigDB)(this._database);
            return (await config
                .getCollection('collections')
                .updateOne({ _id: ns }, { $unset: { enableAutoMerge: 1 } }, { writeConcern: { w: 'majority', wtimeout: 60000 } }));
        }
        async checkMetadataConsistency(options = {}) {
            this._emitShardApiCall('checkMetadataConsistency', { options });
            return this._database._runAdminCursorCommand({
                checkMetadataConsistency: 1,
            });
        }
    };
    __setFunctionName(_classThis, "Shard");
    (() => {
        var _a;
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create((_a = _classSuper[Symbol.metadata]) !== null && _a !== void 0 ? _a : null) : void 0;
        _enableSharding_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _commitReshardCollection_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['5.0.0', enums_1.ServerVersions.latest])];
        _abortReshardCollection_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['5.0.0', enums_1.ServerVersions.latest])];
        _shardCollection_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _reshardCollection_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['5.0.0', enums_1.ServerVersions.latest])];
        _status_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([1])];
        _addShard_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _addShardToZone_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])];
        _addShardTag_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])];
        _updateZoneKeyRange_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _addTagRange_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])];
        _removeRangeFromZone_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])];
        _removeTagRange_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])];
        _removeShardFromZone_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])];
        _removeShardTag_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])];
        _enableAutoSplit_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([1]), (0, decorators_1.serverVersions)(['3.4.0', '6.0.2'])];
        _disableAutoSplit_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([1]), (0, decorators_1.serverVersions)(['3.4.0', '6.0.2'])];
        _splitAt_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _splitFind_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _moveChunk_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _balancerCollectionStatus_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['4.4.0', enums_1.ServerVersions.latest])];
        _enableBalancing_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _disableBalancing_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _getBalancerState_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _isBalancerRunning_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _startBalancer_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _stopBalancer_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _setBalancerState_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([])];
        _getShardedDataDistribution_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['6.0.3', enums_1.ServerVersions.latest]), (0, decorators_1.returnType)('AggregationCursor')];
        _startAutoMerger_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])];
        _stopAutoMerger_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])];
        _isAutoMergerEnabled_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])];
        _disableAutoMerger_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])];
        _enableAutoMerger_decorators = [decorators_1.returnsPromise, (0, decorators_1.apiVersions)([]), (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])];
        _checkMetadataConsistency_decorators = [decorators_1.returnsPromise, (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])];
        __esDecorate(_classThis, null, _enableSharding_decorators, { kind: "method", name: "enableSharding", static: false, private: false, access: { has: obj => "enableSharding" in obj, get: obj => obj.enableSharding }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _commitReshardCollection_decorators, { kind: "method", name: "commitReshardCollection", static: false, private: false, access: { has: obj => "commitReshardCollection" in obj, get: obj => obj.commitReshardCollection }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _abortReshardCollection_decorators, { kind: "method", name: "abortReshardCollection", static: false, private: false, access: { has: obj => "abortReshardCollection" in obj, get: obj => obj.abortReshardCollection }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _shardCollection_decorators, { kind: "method", name: "shardCollection", static: false, private: false, access: { has: obj => "shardCollection" in obj, get: obj => obj.shardCollection }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _reshardCollection_decorators, { kind: "method", name: "reshardCollection", static: false, private: false, access: { has: obj => "reshardCollection" in obj, get: obj => obj.reshardCollection }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _status_decorators, { kind: "method", name: "status", static: false, private: false, access: { has: obj => "status" in obj, get: obj => obj.status }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _addShard_decorators, { kind: "method", name: "addShard", static: false, private: false, access: { has: obj => "addShard" in obj, get: obj => obj.addShard }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _addShardToZone_decorators, { kind: "method", name: "addShardToZone", static: false, private: false, access: { has: obj => "addShardToZone" in obj, get: obj => obj.addShardToZone }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _addShardTag_decorators, { kind: "method", name: "addShardTag", static: false, private: false, access: { has: obj => "addShardTag" in obj, get: obj => obj.addShardTag }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _updateZoneKeyRange_decorators, { kind: "method", name: "updateZoneKeyRange", static: false, private: false, access: { has: obj => "updateZoneKeyRange" in obj, get: obj => obj.updateZoneKeyRange }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _addTagRange_decorators, { kind: "method", name: "addTagRange", static: false, private: false, access: { has: obj => "addTagRange" in obj, get: obj => obj.addTagRange }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _removeRangeFromZone_decorators, { kind: "method", name: "removeRangeFromZone", static: false, private: false, access: { has: obj => "removeRangeFromZone" in obj, get: obj => obj.removeRangeFromZone }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _removeTagRange_decorators, { kind: "method", name: "removeTagRange", static: false, private: false, access: { has: obj => "removeTagRange" in obj, get: obj => obj.removeTagRange }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _removeShardFromZone_decorators, { kind: "method", name: "removeShardFromZone", static: false, private: false, access: { has: obj => "removeShardFromZone" in obj, get: obj => obj.removeShardFromZone }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _removeShardTag_decorators, { kind: "method", name: "removeShardTag", static: false, private: false, access: { has: obj => "removeShardTag" in obj, get: obj => obj.removeShardTag }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _enableAutoSplit_decorators, { kind: "method", name: "enableAutoSplit", static: false, private: false, access: { has: obj => "enableAutoSplit" in obj, get: obj => obj.enableAutoSplit }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _disableAutoSplit_decorators, { kind: "method", name: "disableAutoSplit", static: false, private: false, access: { has: obj => "disableAutoSplit" in obj, get: obj => obj.disableAutoSplit }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _splitAt_decorators, { kind: "method", name: "splitAt", static: false, private: false, access: { has: obj => "splitAt" in obj, get: obj => obj.splitAt }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _splitFind_decorators, { kind: "method", name: "splitFind", static: false, private: false, access: { has: obj => "splitFind" in obj, get: obj => obj.splitFind }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _moveChunk_decorators, { kind: "method", name: "moveChunk", static: false, private: false, access: { has: obj => "moveChunk" in obj, get: obj => obj.moveChunk }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _balancerCollectionStatus_decorators, { kind: "method", name: "balancerCollectionStatus", static: false, private: false, access: { has: obj => "balancerCollectionStatus" in obj, get: obj => obj.balancerCollectionStatus }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _enableBalancing_decorators, { kind: "method", name: "enableBalancing", static: false, private: false, access: { has: obj => "enableBalancing" in obj, get: obj => obj.enableBalancing }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _disableBalancing_decorators, { kind: "method", name: "disableBalancing", static: false, private: false, access: { has: obj => "disableBalancing" in obj, get: obj => obj.disableBalancing }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _getBalancerState_decorators, { kind: "method", name: "getBalancerState", static: false, private: false, access: { has: obj => "getBalancerState" in obj, get: obj => obj.getBalancerState }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _isBalancerRunning_decorators, { kind: "method", name: "isBalancerRunning", static: false, private: false, access: { has: obj => "isBalancerRunning" in obj, get: obj => obj.isBalancerRunning }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _startBalancer_decorators, { kind: "method", name: "startBalancer", static: false, private: false, access: { has: obj => "startBalancer" in obj, get: obj => obj.startBalancer }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _stopBalancer_decorators, { kind: "method", name: "stopBalancer", static: false, private: false, access: { has: obj => "stopBalancer" in obj, get: obj => obj.stopBalancer }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _setBalancerState_decorators, { kind: "method", name: "setBalancerState", static: false, private: false, access: { has: obj => "setBalancerState" in obj, get: obj => obj.setBalancerState }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _getShardedDataDistribution_decorators, { kind: "method", name: "getShardedDataDistribution", static: false, private: false, access: { has: obj => "getShardedDataDistribution" in obj, get: obj => obj.getShardedDataDistribution }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _startAutoMerger_decorators, { kind: "method", name: "startAutoMerger", static: false, private: false, access: { has: obj => "startAutoMerger" in obj, get: obj => obj.startAutoMerger }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _stopAutoMerger_decorators, { kind: "method", name: "stopAutoMerger", static: false, private: false, access: { has: obj => "stopAutoMerger" in obj, get: obj => obj.stopAutoMerger }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _isAutoMergerEnabled_decorators, { kind: "method", name: "isAutoMergerEnabled", static: false, private: false, access: { has: obj => "isAutoMergerEnabled" in obj, get: obj => obj.isAutoMergerEnabled }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _disableAutoMerger_decorators, { kind: "method", name: "disableAutoMerger", static: false, private: false, access: { has: obj => "disableAutoMerger" in obj, get: obj => obj.disableAutoMerger }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _enableAutoMerger_decorators, { kind: "method", name: "enableAutoMerger", static: false, private: false, access: { has: obj => "enableAutoMerger" in obj, get: obj => obj.enableAutoMerger }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(_classThis, null, _checkMetadataConsistency_decorators, { kind: "method", name: "checkMetadataConsistency", static: false, private: false, access: { has: obj => "checkMetadataConsistency" in obj, get: obj => obj.checkMetadataConsistency }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
        Shard = _classThis = _classDescriptor.value;
        if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        __runInitializers(_classThis, _classExtraInitializers);
    })();
    return Shard = _classThis;
})();
exports.default = Shard;
//# sourceMappingURL=shard.js.map