"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const babel = __importStar(require("@babel/core"));
function asNodeKey(v) {
    return v;
}
const isGeneratedInnerFunction = asNodeKey(Symbol('isGeneratedInnerFunction'));
const isWrappedForOfLoop = asNodeKey(Symbol('isWrappedForOfLoop'));
const isGeneratedHelper = asNodeKey(Symbol('isGeneratedHelper'));
const isOriginalBody = asNodeKey(Symbol('isOriginalBody'));
const isAlwaysSyncFunction = asNodeKey(Symbol('isAlwaysSyncFunction'));
const isExpandedTypeof = asNodeKey(Symbol('isExpandedTypeof'));
const identifierGroupKey = '@@mongosh.identifierGroup';
const syntheticPromiseSymbolTemplate = babel.template.statements `
  const SP_IDENTIFIER = Symbol.for("@@mongosh.syntheticPromise");
  const SAI_IDENTIFIER = Symbol.for("@@mongosh.syntheticAsyncIterable");
`;
const markSyntheticPromiseTemplate = babel.template.statement `
  function MSP_IDENTIFIER(p) {
    return Object.defineProperty(p, SP_IDENTIFIER, {
      value: true
    });
  }
`;
const isSyntheticPromiseTemplate = babel.template.statement `
  function ISP_IDENTIFIER(p) {
    return p && p[SP_IDENTIFIER];
  }
`;
const assertNotSyntheticPromiseTemplate = babel.template.statement `
  function ANSP_IDENTIFIER(p, s, i = false) {
    if (p && p[SP_IDENTIFIER]) {
      throw new CUSTOM_ERROR_BUILDER(
        'Result of expression "' + s + '" cannot be used in this context',
        'SyntheticPromiseInAlwaysSyncContext');
    }
    if (i && p && p[SAI_IDENTIFIER]) {
      throw new CUSTOM_ERROR_BUILDER(
        'Result of expression "' + s + '" cannot be iterated in this context',
        'SyntheticAsyncIterableInAlwaysSyncContext');
    }
    return p;
  }
`;
const adaptAsyncIterableToSyncIterableTemplate = babel.template.statement `
  function AAITSI_IDENTIFIER(original) {
    if (!original || !original[SAI_IDENTIFIER]) {
      return { iterable: original, isSyntheticAsyncIterable: false };
    }
    const originalIterator = original[Symbol.asyncIterator]();
    let next;
    let returned;

    return {
      isSyntheticAsyncIterable: true,
      iterable: {
        [Symbol.iterator]() {
          return this;
        },
        next() {
          let _next = next;
          next = undefined;
          return _next;
        },
        return(value) {
          returned = { value };
          return {
            value,
            done: true
          }
        },
        async expectNext() {
          next ??= await originalIterator.next();
        },
        async syncReturn() {
          if (returned) {
            await originalIterator.return(returned.value);
          }
        }
      }
    }
  }
`;
const asyncTryCatchWrapperTemplate = babel.template.expression `
  async () => {
    try {
      ORIGINAL_CODE;
    } catch (err) {
      if (FUNCTION_STATE_IDENTIFIER === "sync") {
        SYNC_RETURN_VALUE_IDENTIFIER = err;
        FUNCTION_STATE_IDENTIFIER = "threw";
      } else throw err;
    } finally {
      if (FUNCTION_STATE_IDENTIFIER !== "threw") FUNCTION_STATE_IDENTIFIER = "returned";
    }
  }
`;
const expressionHolderVariableTemplate = babel.template.statement `
  let EXPRESSION_HOLDER_IDENTIFIER;`;
const wrapperFunctionTemplate = babel.template.statements `
  let FUNCTION_STATE_IDENTIFIER = "sync",
      SYNC_RETURN_VALUE_IDENTIFIER;

  const ASYNC_RETURN_VALUE_IDENTIFIER = (ASYNC_TRY_CATCH_WRAPPER)();

  if (FUNCTION_STATE_IDENTIFIER === "returned")
    return SYNC_RETURN_VALUE_IDENTIFIER;
  else if (FUNCTION_STATE_IDENTIFIER === "threw")
    throw SYNC_RETURN_VALUE_IDENTIFIER;
  FUNCTION_STATE_IDENTIFIER = "async";
  return MSP_IDENTIFIER(ASYNC_RETURN_VALUE_IDENTIFIER);
`;
const awaitSyntheticPromiseTemplate = babel.template.expression `(
  ORIGINAL_SOURCE,
  EXPRESSION_HOLDER = NODE,
  ISP_IDENTIFIER(EXPRESSION_HOLDER) ? await EXPRESSION_HOLDER : EXPRESSION_HOLDER
)`;
const rethrowTemplate = babel.template.statement `
  try {
    ORIGINAL_CODE;
  } catch (err) {
    throw err;
  }
`;
const forOfLoopTemplate = babel.template.statement `{
  const ITERABLE_INFO = AAITSI_IDENTIFIER(ORIGINAL_ITERABLE);
  const ITERABLE_ISAI = (ITERABLE_INFO).isSyntheticAsyncIterable;
  const ITERABLE = (ITERABLE_INFO).iterable;

  try {
    ITERABLE_ISAI && await (ITERABLE).expectNext();
    for (const ITEM of (ORIGINAL_ITERABLE_SOURCE, ITERABLE)) {
      ORIGINAL_DECLARATION;
      try {
        ORIGINAL_BODY;
      } finally {
        ITERABLE_ISAI && await (ITERABLE).expectNext();
      }
    }
  } finally {
    ITERABLE_ISAI && await (ITERABLE).syncReturn();
  }
}`;
const demangleErrorTemplate = babel.template.statement `
  function DE_IDENTIFIER(err) {
    if (Object.prototype.toString.call(err) === '[object Error]' &&
        err.message.includes('\\ufeff')) {
      err.message = err.message.replace(/\\(\\s*"\\ufeff(.+?)\\ufeff"\\s*,(?:[^\\(]|\\([^\)]*\\))*\\)/g, (m,o) => o);
    }
    return err;
  }
`;
const returnValueWrapperTemplate = babel.template.expression `(
  SYNC_RETURN_VALUE_IDENTIFIER = NODE,
  FUNCTION_STATE_IDENTIFIER === 'async' ? SYNC_RETURN_VALUE_IDENTIFIER : null
)`;
exports.default = ({ types: t, }) => {
    function getOriginalSourceString({ file }, node, { wrap = true } = {}) {
        var _a, _b;
        const prettyOriginalString = limitStringLength(node.start !== undefined
            ? file.code.slice((_a = node.start) !== null && _a !== void 0 ? _a : undefined, (_b = node.end) !== null && _b !== void 0 ? _b : undefined)
            : '<unknown>', 25);
        if (!wrap)
            return t.stringLiteral(prettyOriginalString);
        return t.stringLiteral('\ufeff' + prettyOriginalString + '\ufeff');
    }
    return {
        pre(file) {
            this.file = file;
        },
        visitor: {
            BlockStatement(path) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                if (!path.parentPath.isFunction())
                    return;
                if (path.parentPath.getData(identifierGroupKey))
                    return;
                if (path.parentPath.node[isGeneratedInnerFunction])
                    return;
                if (path.parentPath.node[isGeneratedHelper])
                    return;
                const originalSource = path.parent.start !== undefined
                    ? this.file.code.slice((_a = path.parent.start) !== null && _a !== void 0 ? _a : undefined, (_b = path.parent.end) !== null && _b !== void 0 ? _b : undefined)
                    : 'function () { [unknown code] }';
                const encodedOriginalSource = encodeURIComponent(originalSource);
                const originalSourceNode = t.expressionStatement(t.stringLiteral(`<async_rewriter>${encodedOriginalSource}</>`));
                const existingIdentifiers = (_c = path
                    .findParent((path) => !!path.getData(identifierGroupKey))) === null || _c === void 0 ? void 0 : _c.getData(identifierGroupKey);
                const functionState = path.scope.generateUidIdentifier('fs');
                const synchronousReturnValue = path.scope.generateUidIdentifier('srv');
                const asynchronousReturnValue = path.scope.generateUidIdentifier('arv');
                const expressionHolder = (_d = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.expressionHolder) !== null && _d !== void 0 ? _d : path.scope.generateUidIdentifier('ex');
                const markSyntheticPromise = (_e = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.markSyntheticPromise) !== null && _e !== void 0 ? _e : path.scope.generateUidIdentifier('msp');
                const isSyntheticPromise = (_f = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.isSyntheticPromise) !== null && _f !== void 0 ? _f : path.scope.generateUidIdentifier('isp');
                const adaptAsyncIterableToSyncIterable = (_g = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.adaptAsyncIterableToSyncIterable) !== null && _g !== void 0 ? _g : path.scope.generateUidIdentifier('aaitsi');
                const assertNotSyntheticPromise = (_h = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.assertNotSyntheticPromise) !== null && _h !== void 0 ? _h : path.scope.generateUidIdentifier('ansp');
                const syntheticPromiseSymbol = (_j = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.syntheticPromiseSymbol) !== null && _j !== void 0 ? _j : path.scope.generateUidIdentifier('sp');
                const syntheticAsyncIterableSymbol = (_k = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.syntheticAsyncIterableSymbol) !== null && _k !== void 0 ? _k : path.scope.generateUidIdentifier('sai');
                const demangleError = (_l = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.demangleError) !== null && _l !== void 0 ? _l : path.scope.generateUidIdentifier('de');
                const identifiersGroup = {
                    functionState,
                    synchronousReturnValue,
                    asynchronousReturnValue,
                    expressionHolder,
                    markSyntheticPromise,
                    isSyntheticPromise,
                    adaptAsyncIterableToSyncIterable,
                    assertNotSyntheticPromise,
                    syntheticPromiseSymbol,
                    syntheticAsyncIterableSymbol,
                    demangleError,
                };
                path.parentPath.setData(identifierGroupKey, identifiersGroup);
                const commonHelpers = existingIdentifiers
                    ? []
                    : [
                        ...syntheticPromiseSymbolTemplate({
                            SP_IDENTIFIER: syntheticPromiseSymbol,
                            SAI_IDENTIFIER: syntheticAsyncIterableSymbol,
                        }).map((helper) => Object.assign(helper, { [isGeneratedHelper]: true })),
                        Object.assign(expressionHolderVariableTemplate({
                            EXPRESSION_HOLDER_IDENTIFIER: expressionHolder,
                        }), { [isGeneratedHelper]: true }),
                    ];
                const promiseHelpers = existingIdentifiers
                    ? []
                    : [
                        ...commonHelpers,
                        Object.assign(markSyntheticPromiseTemplate({
                            MSP_IDENTIFIER: markSyntheticPromise,
                            SP_IDENTIFIER: syntheticPromiseSymbol,
                        }), { [isGeneratedHelper]: true }),
                        Object.assign(adaptAsyncIterableToSyncIterableTemplate({
                            AAITSI_IDENTIFIER: adaptAsyncIterableToSyncIterable,
                            SAI_IDENTIFIER: syntheticAsyncIterableSymbol,
                        }), { [isGeneratedHelper]: true }),
                        Object.assign(isSyntheticPromiseTemplate({
                            ISP_IDENTIFIER: isSyntheticPromise,
                            SP_IDENTIFIER: syntheticPromiseSymbol,
                        }), { [isGeneratedHelper]: true }),
                        Object.assign(demangleErrorTemplate({
                            DE_IDENTIFIER: demangleError,
                        }), { [isGeneratedHelper]: true }),
                    ];
                const syncFnHelpers = [
                    ...commonHelpers,
                    Object.assign(assertNotSyntheticPromiseTemplate({
                        ANSP_IDENTIFIER: assertNotSyntheticPromise,
                        SP_IDENTIFIER: syntheticPromiseSymbol,
                        SAI_IDENTIFIER: syntheticAsyncIterableSymbol,
                        CUSTOM_ERROR_BUILDER: (_m = this.opts.customErrorBuilder) !== null && _m !== void 0 ? _m : t.identifier('Error'),
                    }), { [isGeneratedHelper]: true }),
                ];
                if (path.parentPath.node.async) {
                    path.replaceWith(t.blockStatement([
                        originalSourceNode,
                        ...promiseHelpers,
                        rethrowTemplate({
                            ORIGINAL_CODE: path.node.body,
                        }),
                    ]));
                    return;
                }
                if (path.parentPath.node.generator ||
                    (path.parentPath.isClassMethod() &&
                        path.parentPath.node.key.type === 'Identifier' &&
                        path.parentPath.node.key.name === 'constructor')) {
                    Object.assign(path.parentPath.node, { [isAlwaysSyncFunction]: true });
                    path.replaceWith(t.blockStatement([
                        originalSourceNode,
                        ...syncFnHelpers,
                        rethrowTemplate({
                            ORIGINAL_CODE: path.node.body,
                        }),
                    ]));
                    return;
                }
                const asyncTryCatchWrapper = Object.assign(asyncTryCatchWrapperTemplate({
                    FUNCTION_STATE_IDENTIFIER: functionState,
                    SYNC_RETURN_VALUE_IDENTIFIER: synchronousReturnValue,
                    ORIGINAL_CODE: Object.assign(path.node, { [isOriginalBody]: true }),
                }), { [isGeneratedInnerFunction]: true });
                const wrapperFunction = wrapperFunctionTemplate({
                    FUNCTION_STATE_IDENTIFIER: functionState,
                    SYNC_RETURN_VALUE_IDENTIFIER: synchronousReturnValue,
                    ASYNC_RETURN_VALUE_IDENTIFIER: asynchronousReturnValue,
                    MSP_IDENTIFIER: markSyntheticPromise,
                    ASYNC_TRY_CATCH_WRAPPER: asyncTryCatchWrapper,
                });
                path.replaceWith(t.blockStatement([
                    originalSourceNode,
                    ...promiseHelpers,
                    ...wrapperFunction,
                ]));
            },
            UnaryExpression: {
                enter(path) {
                    if (path.node.operator === 'typeof' &&
                        path.node.argument.type === 'Identifier' &&
                        !path.node[isExpandedTypeof]) {
                        path.replaceWith(t.conditionalExpression(t.binaryExpression('===', {
                            ...path.node,
                            [isGeneratedHelper]: true,
                            [isExpandedTypeof]: true,
                        }, t.stringLiteral('undefined')), t.stringLiteral('undefined'), { ...path.node, [isExpandedTypeof]: true }));
                    }
                },
            },
            Expression: {
                enter(path) {
                    var _a, _b;
                    if (path.parentPath.isArrowFunctionExpression() &&
                        path.key === 'body') {
                        path.replaceWith(t.blockStatement([t.returnStatement(path.node)]));
                    }
                    if ((_b = (_a = path.find((path) => path.isFunction() || !!path.node[isGeneratedHelper])) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b[isGeneratedHelper]) {
                        return path.skip();
                    }
                },
                exit(path) {
                    var _a, _b, _c, _d;
                    const functionParent = path.getFunctionParent();
                    if (!functionParent)
                        return;
                    if (!functionParent.node.async &&
                        !functionParent.node[isAlwaysSyncFunction])
                        return;
                    let identifierGroup;
                    if (functionParent.node[isGeneratedInnerFunction]) {
                        if (!((_b = (_a = path.findParent((path) => path.isFunction() || !!path.node[isOriginalBody])) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b[isOriginalBody])) {
                            return;
                        }
                        identifierGroup = (_d = (_c = functionParent
                            .getFunctionParent()) === null || _c === void 0 ? void 0 : _c.getData) === null || _d === void 0 ? void 0 : _d.call(_c, identifierGroupKey);
                        if (!identifierGroup) {
                            throw new Error('Parent of generated inner function does not have existing identifiers available');
                        }
                        if (path.parentPath.isReturnStatement() &&
                            !path.node[isGeneratedHelper]) {
                            path.replaceWith(Object.assign(returnValueWrapperTemplate({
                                SYNC_RETURN_VALUE_IDENTIFIER: identifierGroup.synchronousReturnValue,
                                FUNCTION_STATE_IDENTIFIER: identifierGroup.functionState,
                                NODE: path.node,
                            }), { [isGeneratedHelper]: true }));
                            return;
                        }
                    }
                    else {
                        identifierGroup = functionParent.getData(identifierGroupKey);
                    }
                    if (path.parentPath.isCallExpression() &&
                        path.key === 'callee' &&
                        (path.isMemberExpression() ||
                            path.isImport() ||
                            (path.isIdentifier() && path.node.name === 'eval'))) {
                        return;
                    }
                    if (path.parentPath.isAssignmentExpression() && path.key === 'left')
                        return;
                    if (path.parentPath.isForXStatement() && path.key === 'left')
                        return;
                    if (path.parentPath.isUpdateExpression())
                        return;
                    if (path.parentPath.isUnaryExpression() &&
                        path.parentPath.node.operator === 'delete')
                        return;
                    if (path.isLiteral() ||
                        path.isArrayExpression() ||
                        path.isObjectExpression() ||
                        path.isFunctionExpression() ||
                        path.isArrowFunctionExpression() ||
                        path.isClassExpression() ||
                        path.isAssignmentExpression() ||
                        path.isBinaryExpression() ||
                        path.isConditionalExpression() ||
                        path.isLogicalExpression() ||
                        path.isSequenceExpression() ||
                        path.isParenthesizedExpression() ||
                        path.isUnaryExpression() ||
                        path.isSuper() ||
                        path.isThisExpression() ||
                        path.isAwaitExpression() ||
                        path.parentPath.isAwaitExpression()) {
                        return;
                    }
                    if (path.isIdentifier() && path.scope.hasBinding(path.node.name))
                        return;
                    const { expressionHolder, isSyntheticPromise, assertNotSyntheticPromise, } = identifierGroup;
                    if (!functionParent.node.async) {
                        const args = [
                            path.node,
                            getOriginalSourceString(this, path.node, {
                                wrap: false,
                            }),
                        ];
                        if ((path.parent.type === 'ForOfStatement' &&
                            path.node === path.parent.right) ||
                            (path.parent.type === 'YieldExpression' && path.parent.delegate)) {
                            args.push(t.booleanLiteral(true));
                        }
                        path.replaceWith(Object.assign(t.callExpression(assertNotSyntheticPromise, args), {
                            [isGeneratedHelper]: true,
                        }));
                        return;
                    }
                    path.replaceWith(Object.assign(awaitSyntheticPromiseTemplate({
                        ORIGINAL_SOURCE: getOriginalSourceString(this, path.node),
                        EXPRESSION_HOLDER: expressionHolder,
                        ISP_IDENTIFIER: isSyntheticPromise,
                        NODE: path.node,
                    }), { [isGeneratedHelper]: true }));
                    path.skip();
                },
            },
            CatchClause: {
                exit(path) {
                    var _a;
                    if (path.node[isGeneratedHelper] ||
                        !path.node.param ||
                        path.node.param.type !== 'Identifier')
                        return;
                    const existingIdentifiers = (_a = path
                        .findParent((path) => !!path.getData(identifierGroupKey))) === null || _a === void 0 ? void 0 : _a.getData(identifierGroupKey);
                    if (!existingIdentifiers)
                        return;
                    path.replaceWith(Object.assign(t.catchClause(path.node.param, t.blockStatement([
                        t.expressionStatement(t.assignmentExpression('=', path.node.param, t.callExpression(existingIdentifiers.demangleError, [
                            path.node.param,
                        ]))),
                        path.node.body,
                    ])), { [isGeneratedHelper]: true }));
                },
            },
            ForOfStatement(path) {
                var _a, _b, _c, _d, _e, _f;
                if (path.node.await || !((_a = path.getFunctionParent()) === null || _a === void 0 ? void 0 : _a.node.async))
                    return;
                if ((_c = (_b = path.find((path) => path.isFunction() || !!path.node[isGeneratedHelper])) === null || _b === void 0 ? void 0 : _b.node) === null || _c === void 0 ? void 0 : _c[isGeneratedHelper]) {
                    return path.skip();
                }
                if ((_e = (_d = path.find((path) => path.isFunction() || !!path.node[isWrappedForOfLoop])) === null || _d === void 0 ? void 0 : _d.node) === null || _e === void 0 ? void 0 : _e[isWrappedForOfLoop]) {
                    return;
                }
                const identifierGroup = (_f = path
                    .findParent((path) => !!path.getData(identifierGroupKey))) === null || _f === void 0 ? void 0 : _f.getData(identifierGroupKey);
                if (!identifierGroup)
                    throw new Error('Missing identifier group for ForOfStatement');
                const { adaptAsyncIterableToSyncIterable } = identifierGroup;
                const item = path.scope.generateUidIdentifier('i');
                path.replaceWith(Object.assign(forOfLoopTemplate({
                    ORIGINAL_ITERABLE: path.node.right,
                    ORIGINAL_ITERABLE_SOURCE: getOriginalSourceString(this, path.node.right),
                    ORIGINAL_DECLARATION: path.node.left.type === 'VariableDeclaration'
                        ? t.variableDeclaration(path.node.left.kind, path.node.left.declarations.map((d) => ({
                            ...d,
                            init: item,
                        })))
                        : t.expressionStatement(t.assignmentExpression('=', path.node.left, item)),
                    ORIGINAL_BODY: path.node.body,
                    ITERABLE_INFO: path.scope.generateUidIdentifier('ii'),
                    ITERABLE_ISAI: path.scope.generateUidIdentifier('isai'),
                    ITERABLE: path.scope.generateUidIdentifier('it'),
                    ITEM: item,
                    AAITSI_IDENTIFIER: adaptAsyncIterableToSyncIterable,
                }), { [isWrappedForOfLoop]: true }));
            },
        },
    };
};
function limitStringLength(input, maxLength) {
    if (input.length <= maxLength)
        return input;
    return (input.slice(0, (maxLength - 5) * 0.7) +
        ' ... ' +
        input.slice(input.length - (maxLength - 5) * 0.3));
}
//# sourceMappingURL=transform-maybe-await.js.map