"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShellEvaluator = void 0;
const shell_api_1 = require("@mongosh/shell-api");
const async_rewriter2_1 = __importDefault(require("@mongosh/async-rewriter2"));
const history_1 = require("@mongosh/history");
const types_1 = require("@mongosh/types");
let hasAlreadyRunGlobalRuntimeSupportEval = false;
let v8;
try {
    v8 = require('v8');
}
catch (_c) {
}
if ((_b = (_a = v8 === null || v8 === void 0 ? void 0 : v8.startupSnapshot) === null || _a === void 0 ? void 0 : _a.isBuildingSnapshot) === null || _b === void 0 ? void 0 : _b.call(_a)) {
    v8.startupSnapshot.addSerializeCallback(() => {
        eval(new async_rewriter2_1.default().runtimeSupportCode());
        eval(new async_rewriter2_1.default().process('1+1'));
        hasAlreadyRunGlobalRuntimeSupportEval = true;
    });
}
class ShellEvaluator {
    constructor(instanceState, resultHandler = shell_api_1.toShellResult, markTime, exposeAsyncRewriter) {
        this.hasAppliedAsyncWriterRuntimeSupport = true;
        this.instanceState = instanceState;
        this.resultHandler = resultHandler;
        this.asyncWriter = new async_rewriter2_1.default();
        this.hasAppliedAsyncWriterRuntimeSupport = false;
        this.exposeAsyncRewriter = !!exposeAsyncRewriter;
        this.markTime = markTime;
    }
    async innerEval(originalEval, input, context, filename) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { shellApi } = this.instanceState;
        const trimmedInput = input.trim();
        const argv = trimmedInput.replace(/;$/, '').split(/\s+/g);
        const cmd = argv.shift();
        if (((_a = shellApi[cmd]) === null || _a === void 0 ? void 0 : _a.isDirectShellCommand) &&
            ((_b = shellApi[cmd]) === null || _b === void 0 ? void 0 : _b.acceptsRawInput) &&
            !((_c = argv[0]) !== null && _c !== void 0 ? _c : '').startsWith('(')) {
            const rawArg = trimmedInput.replace(/^\S+\s*/, '');
            return shellApi[cmd](rawArg);
        }
        if (((_d = shellApi[cmd]) === null || _d === void 0 ? void 0 : _d.isDirectShellCommand) &&
            !((_e = argv[0]) !== null && _e !== void 0 ? _e : '').startsWith('(')) {
            return shellApi[cmd](...argv);
        }
        if (this.exposeAsyncRewriter) {
            context.__asyncRewrite = (rewriteInput) => this.asyncWriter.process(rewriteInput);
        }
        (_f = this.markTime) === null || _f === void 0 ? void 0 : _f.call(this, types_1.TimingCategories.AsyncRewrite, 'start async rewrite');
        let rewrittenInput = this.asyncWriter.process(input);
        (_g = this.markTime) === null || _g === void 0 ? void 0 : _g.call(this, types_1.TimingCategories.AsyncRewrite, 'done async rewrite');
        const hiddenCommands = RegExp(history_1.HIDDEN_COMMANDS, 'g');
        if (!hiddenCommands.test(input) && !hiddenCommands.test(rewrittenInput)) {
            this.instanceState.messageBus.emit('mongosh:evaluate-input', {
                input: (0, history_1.redactSensitiveData)(trimmedInput),
            });
        }
        if (!this.hasAppliedAsyncWriterRuntimeSupport) {
            this.hasAppliedAsyncWriterRuntimeSupport = true;
            (_h = this.markTime) === null || _h === void 0 ? void 0 : _h.call(this, types_1.TimingCategories.AsyncRewrite, 'start runtimeSupportCode processing');
            const supportCode = this.asyncWriter.runtimeSupportCode();
            if (!hasAlreadyRunGlobalRuntimeSupportEval) {
                eval(supportCode);
            }
            (_j = this.markTime) === null || _j === void 0 ? void 0 : _j.call(this, types_1.TimingCategories.AsyncRewrite, 'done global runtimeSupportCode processing');
            rewrittenInput = supportCode + ';\n' + rewrittenInput;
        }
        try {
            (_k = this.markTime) === null || _k === void 0 ? void 0 : _k.call(this, types_1.TimingCategories.Eval, 'started evaluating processed code');
            return await originalEval(rewrittenInput, context, filename);
        }
        catch (err) {
            throw this.instanceState.transformError(err);
        }
        finally {
            (_l = this.markTime) === null || _l === void 0 ? void 0 : _l.call(this, types_1.TimingCategories.Eval, 'finished evaluating processed code');
        }
    }
    async customEval(originalEval, input, context, filename) {
        const evaluationResult = await this.innerEval(originalEval, input, context, filename);
        return await this.resultHandler(evaluationResult);
    }
}
exports.ShellEvaluator = ShellEvaluator;
//# sourceMappingURL=shell-evaluator.js.map