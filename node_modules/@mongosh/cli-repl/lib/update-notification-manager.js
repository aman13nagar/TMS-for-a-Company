"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateNotificationManager = void 0;
const semver_1 = __importDefault(require("semver"));
const fs_1 = require("fs");
const import_node_fetch_1 = __importDefault(require("@mongosh/import-node-fetch"));
const fetch = async (url, init) => await (await (0, import_node_fetch_1.default)()).default(url, init);
class UpdateNotificationManager {
    constructor() {
        this.latestKnownMongoshVersion = undefined;
        this.localFilesystemFetchInProgress = undefined;
    }
    async getLatestVersionIfMoreRecent(currentVersion) {
        try {
            await this.localFilesystemFetchInProgress;
        }
        catch (_a) {
        }
        if (!this.latestKnownMongoshVersion)
            return null;
        if (currentVersion &&
            !semver_1.default.gt(this.latestKnownMongoshVersion, currentVersion))
            return null;
        if (currentVersion && semver_1.default.prerelease(currentVersion))
            return null;
        return this.latestKnownMongoshVersion;
    }
    async fetchUpdateMetadata(updateURL, localFilePath) {
        var _a, _b, _c, _d, _e, _f;
        let localFileContents;
        await (this.localFilesystemFetchInProgress = (async () => {
            let localFileText = '';
            try {
                localFileText = await fs_1.promises.readFile(localFilePath, 'utf-8');
            }
            catch (err) {
                if (!(err &&
                    typeof err === 'object' &&
                    'code' in err &&
                    err.code === 'ENOENT'))
                    throw err;
            }
            try {
                localFileContents = JSON.parse(localFileText);
            }
            catch (_a) {
            }
            if ((localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.updateURL) !== updateURL) {
                localFileContents = undefined;
            }
            if (localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.latestKnownMongoshVersion) {
                this.latestKnownMongoshVersion =
                    localFileContents.latestKnownMongoshVersion;
            }
            this.localFilesystemFetchInProgress = undefined;
        })());
        if ((localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.lastChecked) &&
            Date.now() - localFileContents.lastChecked < 86400000) {
            return;
        }
        const response = await fetch(updateURL, {
            headers: (localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.etag)
                ? { 'if-none-match': localFileContents === null || localFileContents === void 0 ? void 0 : localFileContents.etag }
                : {},
        });
        if (response.status === 304) {
            (_a = response.body) === null || _a === void 0 ? void 0 : _a.once('error', () => {
            }).resume();
            localFileContents = { ...localFileContents, lastChecked: Date.now() };
            await fs_1.promises.writeFile(localFilePath, JSON.stringify(localFileContents));
            return;
        }
        if (!response.ok || !response.body) {
            throw new Error(`Unexpected status code fetching ${updateURL}: ${response.status} ${response.statusText}`);
        }
        const jsonContents = (await response.json());
        this.latestKnownMongoshVersion = (_e = (_d = (_c = (_b = jsonContents === null || jsonContents === void 0 ? void 0 : jsonContents.versions) === null || _b === void 0 ? void 0 : _b.map((v) => v.version)) === null || _c === void 0 ? void 0 : _c.filter((v) => !semver_1.default.prerelease(v))) === null || _d === void 0 ? void 0 : _d.sort(semver_1.default.rcompare)) === null || _e === void 0 ? void 0 : _e[0];
        localFileContents = {
            updateURL,
            lastChecked: Date.now(),
            etag: (_f = response.headers.get('etag')) !== null && _f !== void 0 ? _f : undefined,
            latestKnownMongoshVersion: this.latestKnownMongoshVersion,
        };
        await fs_1.promises.writeFile(localFilePath, JSON.stringify(localFileContents));
    }
}
exports.UpdateNotificationManager = UpdateNotificationManager;
//# sourceMappingURL=update-notification-manager.js.map