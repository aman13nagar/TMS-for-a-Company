"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const autocomplete_1 = __importDefault(require("@mongosh/autocomplete"));
const errors_1 = require("@mongosh/errors");
const history_1 = require("@mongosh/history");
const shell_api_1 = require("@mongosh/shell-api");
const shell_evaluator_1 = require("@mongosh/shell-evaluator");
const types_1 = require("@mongosh/types");
const askcharacter_1 = __importDefault(require("askcharacter"));
const askpassword_1 = __importDefault(require("askpassword"));
const console_1 = require("console");
const events_1 = require("events");
const util_1 = require("util");
const asyncRepl = __importStar(require("./async-repl"));
const clr_1 = __importDefault(require("./clr"));
const constants_1 = require("./constants");
const format_output_1 = __importStar(require("./format-output"));
const js_multiline_to_singleline_1 = require("@mongosh/js-multiline-to-singleline");
const line_by_line_input_1 = require("./line-by-line-input");
const startup_timing_1 = require("./startup-timing");
const vm_1 = require("vm");
class MongoshNodeRepl {
    constructor(options) {
        this.inspectCompact = 0;
        this.inspectDepth = 0;
        this.started = false;
        this.showStackTraces = false;
        this.loadNestingLevel = 0;
        this.redactHistory = 'remove';
        this.rawValueToShellResult = new WeakMap();
        this.input = options.input;
        this.lineByLineInput = new line_by_line_input_1.LineByLineInput(this.input);
        this.output = options.output;
        this.bus = options.bus;
        this.nodeReplOptions = options.nodeReplOptions || {};
        this.shellCliOptions = options.shellCliOptions || {};
        this.ioProvider = options.ioProvider;
        this.insideAutoCompleteOrGetPrompt = false;
        this._runtimeState = null;
    }
    setIsInteractive(value) {
        this.runtimeState().instanceState.isInteractive = value;
    }
    get isInteractive() {
        return this.runtimeState().instanceState.isInteractive;
    }
    async initialize(serviceProvider, moreRecentMongoshVersion) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const usePlainVMContext = this.shellCliOptions.jsContext === 'plain-vm';
        const instanceState = new shell_api_1.ShellInstanceState(serviceProvider, this.bus, this.shellCliOptions);
        const shellEvaluator = new shell_evaluator_1.ShellEvaluator(instanceState, (value) => value, startup_timing_1.markTime, !!this.shellCliOptions.exposeAsyncRewriter);
        instanceState.setEvaluationListener(this);
        instanceState.setPreFetchCollectionAndDatabaseNames(!usePlainVMContext);
        {
            const connectionInfoPromise = instanceState.fetchConnectionInfo();
            connectionInfoPromise.catch(() => {
            });
            if (!this.shellCliOptions.quiet) {
                const connectionInfo = await connectionInfoPromise;
                (0, startup_timing_1.markTime)(types_1.TimingCategories.REPLInstantiation, 'fetched connection info');
                const { buildInfo, extraInfo } = connectionInfo !== null && connectionInfo !== void 0 ? connectionInfo : {};
                let mongodVersion = (extraInfo === null || extraInfo === void 0 ? void 0 : extraInfo.is_stream)
                    ? 'Atlas Stream Processing'
                    : buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.version;
                const apiVersion = (_b = (_a = serviceProvider.getRawClient()) === null || _a === void 0 ? void 0 : _a.serverApi) === null || _b === void 0 ? void 0 : _b.version;
                if (apiVersion) {
                    mongodVersion =
                        (mongodVersion ? mongodVersion + ' ' : '') +
                            `(API Version ${apiVersion})`;
                }
                await this.greet(mongodVersion, moreRecentMongoshVersion);
            }
        }
        await this.printBasicConnectivityWarning(instanceState);
        (0, startup_timing_1.markTime)(types_1.TimingCategories.REPLInstantiation, 'greeted');
        this.inspectCompact =
            (_c = (await this.getConfig('inspectCompact'))) !== null && _c !== void 0 ? _c : this.inspectCompact;
        this.inspectDepth =
            (_d = (await this.getConfig('inspectDepth'))) !== null && _d !== void 0 ? _d : this.inspectDepth;
        this.showStackTraces =
            (_e = (await this.getConfig('showStackTraces'))) !== null && _e !== void 0 ? _e : this.showStackTraces;
        this.redactHistory =
            (_f = (await this.getConfig('redactHistory'))) !== null && _f !== void 0 ? _f : this.redactHistory;
        (0, startup_timing_1.markTime)(types_1.TimingCategories.UserConfigLoading, 'fetched config vars');
        let repl = null;
        let context;
        if (!usePlainVMContext) {
            repl = asyncRepl.start({
                start: require('pretty-repl').start,
                input: this.lineByLineInput,
                output: this.output,
                prompt: '',
                writer: this.writer.bind(this),
                breakEvalOnSigint: true,
                preview: false,
                asyncEval: this.eval.bind(this),
                historySize: await this.getConfig('historyLength'),
                wrapCallbackError: (err) => Object.assign(new errors_1.MongoshInternalError(err.message), {
                    stack: err.stack,
                }),
                onAsyncSigint: this.onAsyncSigint.bind(this),
                ...this.nodeReplOptions,
            });
            context = repl.context;
        }
        else {
            const { builtinModules: nodeReplBuiltinModules } = require('repl');
            context = (0, vm_1.createContext)();
            const jsBuiltinGlobalNames = (0, vm_1.runInContext)('globalThis[Symbol.for("@@mongosh.usingPlainVMContext")] = true;' +
                'Object.getOwnPropertyNames(globalThis)', context);
            for (const nodeJsGlobal of Object.getOwnPropertyNames(globalThis)) {
                if (!jsBuiltinGlobalNames.includes(nodeJsGlobal))
                    Object.defineProperty(context, nodeJsGlobal, {
                        ...Object.getOwnPropertyDescriptor(globalThis, nodeJsGlobal),
                    });
            }
            for (const builtin of nodeReplBuiltinModules) {
                let value;
                Object.defineProperty(context, builtin, {
                    enumerable: false,
                    configurable: true,
                    get() {
                        return (value !== null && value !== void 0 ? value : (value = typeof __non_webpack_require__ === 'function'
                            ? __non_webpack_require__(builtin)
                            : require(builtin)));
                    },
                    set(v) {
                        value = v;
                    },
                });
            }
            context.global = context;
            context.require = require('node:module').createRequire(process.cwd() + '/index.js');
        }
        const console = new console_1.Console({
            stdout: this.output,
            stderr: this.output,
            colorMode: this.getFormatOptions().colors,
        });
        delete context.parcelRequire;
        delete context.__webpack_require__;
        delete context.__non_webpack_require__;
        this.onClearCommand = console.clear.bind(console);
        context.console = console;
        context.Date = Date;
        {
            const globalCryptoDescriptor = (_g = Object.getOwnPropertyDescriptor(context, 'crypto')) !== null && _g !== void 0 ? _g : {};
            if (((_h = globalCryptoDescriptor.value) === null || _h === void 0 ? void 0 : _h.subtle) ||
                ((_k = (_j = globalCryptoDescriptor.get) === null || _j === void 0 ? void 0 : _j.call(null)) === null || _k === void 0 ? void 0 : _k.subtle)) {
                delete context.crypto;
                context.crypto = await Promise.resolve().then(() => __importStar(require('node:crypto')));
            }
        }
        this._runtimeState = {
            shellEvaluator,
            instanceState,
            repl,
            context,
            console,
        };
        (0, startup_timing_1.markTime)(types_1.TimingCategories.REPLInstantiation, 'basic repl/vm initialization complete');
        await this.finishInitializingNodeRepl();
        instanceState.setCtx(context);
        if (!this.shellCliOptions.nodb && !this.shellCliOptions.quiet) {
            const { shellApi } = instanceState;
            const banners = await Promise.all([
                (async () => await shellApi._untrackedShow('startupWarnings'))(),
                (async () => await shellApi._untrackedShow('automationNotices'))(),
                (async () => await shellApi._untrackedShow('nonGenuineMongoDBCheck'))(),
            ]);
            for (const banner of banners) {
                if (banner.value) {
                    await shellApi.print(banner);
                }
            }
        }
        (0, startup_timing_1.markTime)(types_1.TimingCategories.REPLInstantiation, 'finished initialization');
        return { __initialized: 'yes' };
    }
    async finishInitializingNodeRepl() {
        const { repl, instanceState } = this.runtimeState();
        if (!repl)
            return;
        const origReplCompleter = (0, util_1.promisify)(repl.completer.bind(repl));
        const mongoshCompleter = autocomplete_1.default.bind(null, instanceState.getAutocompleteParameters());
        repl.completer = (0, util_1.callbackify)(async (text) => {
            this.insideAutoCompleteOrGetPrompt = true;
            try {
                const [[replResults, replOrig], [mongoshResults, , mongoshResultsExclusive],] = await Promise.all([
                    (async () => (await origReplCompleter(text)) || [[]])(),
                    (async () => await mongoshCompleter(text))(),
                ]);
                this.bus.emit('mongosh:autocompletion-complete');
                if (mongoshResultsExclusive) {
                    return [mongoshResults, text];
                }
                const replResultPrefix = replOrig
                    ? text.substr(0, text.lastIndexOf(replOrig))
                    : '';
                const longReplResults = replResults.map((result) => replResultPrefix + result);
                const deduped = [...new Set([...longReplResults, ...mongoshResults])];
                return [deduped, text];
            }
            finally {
                this.insideAutoCompleteOrGetPrompt = false;
            }
        });
        let originalHistory = null;
        const originalDisplayPrompt = repl.displayPrompt.bind(repl);
        repl.displayPrompt = (...args) => {
            if (!this.started) {
                return;
            }
            originalDisplayPrompt(...args);
            this.lineByLineInput.nextLine();
        };
        if (repl.commands.editor) {
            const originalEditorAction = repl.commands.editor.action.bind(repl);
            repl.commands.editor.action = (...args) => {
                originalHistory = [...repl.history];
                this.lineByLineInput.disableBlockOnNewline();
                return originalEditorAction(...args);
            };
        }
        repl.defineCommand('clear', {
            help: '',
            action: () => {
                repl.displayPrompt();
            },
        });
        repl.line = '';
        (0, startup_timing_1.markTime)(types_1.TimingCategories.REPLInstantiation, 'created repl object');
        const historyFile = this.ioProvider.getHistoryFilePath();
        try {
            await (0, util_1.promisify)(repl.setupHistory).call(repl, historyFile);
            repl.on('line', () => {
                if (this.redactHistory !== 'keep') {
                    const history = repl.history;
                    (0, history_1.changeHistory)(history, this.redactHistory === 'remove-redact'
                        ? 'redact-sensitive-data'
                        : 'keep-sensitive-data');
                }
            });
            repl.on(asyncRepl.evalFinish, (ev) => {
                if (this.insideAutoCompleteOrGetPrompt) {
                    return;
                }
                const history = repl.history;
                if (ev.success === false && ev.recoverable) {
                    if (originalHistory === null) {
                        originalHistory = history.slice(1);
                    }
                }
                else if (originalHistory !== null) {
                    const newHistoryEntry = (0, js_multiline_to_singleline_1.makeMultilineJSIntoSingleLine)(ev.input);
                    if (newHistoryEntry.length > 0) {
                        originalHistory.unshift(newHistoryEntry);
                    }
                    history.splice(0, history.length, ...originalHistory);
                    originalHistory = null;
                }
            });
        }
        catch (err) {
            const warn = new errors_1.MongoshWarning('Error processing history file: ' + (err === null || err === void 0 ? void 0 : err.message));
            this.output.write(this.writer(warn) + '\n');
        }
        (0, startup_timing_1.markTime)(types_1.TimingCategories.UserConfigLoading, 'set up history file');
        repl.on(asyncRepl.evalStart, () => {
            this.bus.emit('mongosh:evaluate-started');
        });
        repl.on(asyncRepl.evalFinish, () => {
            this.bus.emit('mongosh:evaluate-finished');
        });
        repl.on('exit', () => {
            this.onExit().catch(() => {
            });
        });
    }
    async startRepl(_initializationToken) {
        this.started = true;
        const { repl } = this.runtimeState();
        if (!repl) {
            throw new errors_1.MongoshInternalError('Cannot start REPL when not in REPL evaluation mode');
        }
        repl.setPrompt(await this.getShellPrompt());
        this.lineByLineInput.start();
        this.input.resume();
        repl.displayPrompt();
    }
    async greet(mongodVersion, moreRecentMongoshVersion) {
        if (this.shellCliOptions.quiet) {
            return;
        }
        const { version } = require('../package.json');
        let text = '';
        if (!this.shellCliOptions.nodb) {
            text += `Using MongoDB:\t\t${mongodVersion}\n`;
        }
        text += `${this.clr('Using Mongosh', 'mongosh:section-header')}:\t\t${version}\n`;
        if (moreRecentMongoshVersion) {
            text += `mongosh ${this.clr(moreRecentMongoshVersion, 'bold')} is available for download: ${this.clr('https://www.mongodb.com/try/download/shell', 'mongosh:uri')}\n`;
        }
        text += `${constants_1.MONGOSH_WIKI}\n`;
        if (!(await this.getConfig('disableGreetingMessage'))) {
            text += `${constants_1.TELEMETRY_GREETING_MESSAGE}\n`;
            await this.setConfig('disableGreetingMessage', true);
        }
        this.output.write(text);
    }
    async printBasicConnectivityWarning(instanceState) {
        if (this.shellCliOptions.nodb || this.shellCliOptions.quiet) {
            return;
        }
        let err;
        try {
            await instanceState.currentDb.adminCommand({ ping: 1 });
            return;
        }
        catch (error) {
            err = error;
        }
        const text = this.clr('The server failed to respond to a ping and may be unavailable:', 'mongosh:warning');
        this.output.write(text + '\n' + this.formatError(err) + '\n');
    }
    async eval(originalEval, input, context, filename) {
        (0, startup_timing_1.markTime)(types_1.TimingCategories.Eval, 'start repl eval');
        if (!this.insideAutoCompleteOrGetPrompt) {
            this.lineByLineInput.enableBlockOnNewLine();
        }
        const { repl, shellEvaluator } = this.runtimeState();
        let interrupted = false;
        try {
            const rawValue = await shellEvaluator.customEval(originalEval, input, context, filename);
            if ((typeof rawValue === 'object' && rawValue !== null) ||
                typeof rawValue === 'function') {
                this.rawValueToShellResult.set(rawValue, await (0, shell_api_1.toShellResult)(rawValue));
            }
            if (!this.insideAutoCompleteOrGetPrompt ||
                (0, shell_api_1.getShellApiType)(rawValue) === null) {
                return rawValue;
            }
            return Object.fromEntries(Object.entries(rawValue).filter(([key]) => !key.startsWith('_')));
        }
        catch (err) {
            if (this.runtimeState().instanceState.interrupted.isSet()) {
                interrupted = true;
                this.bus.emit('mongosh:eval-interrupted');
                return undefined;
            }
            if (!isErrorLike(err)) {
                throw new Error(this.formatOutput({
                    value: err,
                }));
            }
            throw err;
        }
        finally {
            (0, startup_timing_1.markTime)(types_1.TimingCategories.Eval, 'done repl eval');
            if (!this.insideAutoCompleteOrGetPrompt && !interrupted && repl) {
                repl.setPrompt(await this.getShellPrompt());
            }
            if (this.loadNestingLevel <= 1) {
                this.bus.emit('mongosh:eval-complete');
            }
            (0, startup_timing_1.markTime)(types_1.TimingCategories.Eval, 're-set prompt');
        }
    }
    async onLoad(filename) {
        const { contents, absolutePath } = await this.ioProvider.readFileUTF8(filename);
        return {
            resolvedFilename: absolutePath,
            evaluate: async () => {
                this.loadNestingLevel += 1;
                try {
                    await this.loadExternalCode(contents, absolutePath);
                }
                finally {
                    this.loadNestingLevel -= 1;
                }
            },
        };
    }
    async loadExternalFile(filename) {
        await this.runtimeState().instanceState.shellApi.load(filename);
    }
    async loadExternalCode(input, filename) {
        const { repl, context } = this.runtimeState();
        if (repl) {
            return await (0, util_1.promisify)(repl.eval.bind(repl))(input, context, filename);
        }
        let asyncSigintHandler;
        const asyncSigintPromise = new Promise((resolve, reject) => {
            asyncSigintHandler = () => {
                void this.onAsyncSigint();
                setImmediate(() => reject(new Error('Asynchronous execution was interrupted by `SIGINT`')));
            };
        });
        this.bus.emit('mongosh:evaluate-started');
        try {
            process.addListener('SIGINT', asyncSigintHandler);
            return await Promise.race([
                asyncSigintPromise,
                this.eval((input, context, filename) => new vm_1.Script(input, { filename }).runInContext(context, {
                    breakOnSigint: true,
                }), input, context, filename),
            ]);
        }
        finally {
            process.removeListener('SIGINT', asyncSigintHandler);
            this.bus.emit('mongosh:evaluate-finished');
        }
    }
    async onAsyncSigint() {
        var _a, _b;
        const { instanceState } = this.runtimeState();
        if (instanceState.interrupted.isSet()) {
            return true;
        }
        this.output.write('Stopping execution...');
        const mongodVersion = (_b = (_a = instanceState.cachedConnectionInfo()) === null || _a === void 0 ? void 0 : _a.buildInfo) === null || _b === void 0 ? void 0 : _b.version;
        if (mongodVersion === null || mongodVersion === void 0 ? void 0 : mongodVersion.match(/^(4\.0\.|3\.)\d+/)) {
            this.output.write(this.clr(`\nWARNING: Operations running on the server cannot be killed automatically for MongoDB ${mongodVersion}.` +
                '\n         Please make sure to kill them manually. Killing operations is supported starting with MongoDB 4.1.', 'mongosh:warning'));
        }
        const fullyInterrupted = await instanceState.onInterruptExecution();
        await Promise.race([
            (0, events_1.once)(this.bus, 'mongosh:eval-interrupted'),
            new Promise(setImmediate),
        ]);
        const fullyResumed = await instanceState.onResumeExecution();
        if (!fullyInterrupted || !fullyResumed) {
            this.output.write(this.formatError({
                name: 'MongoshInternalError',
                message: 'Could not re-establish all connections, we suggest to restart the shell.',
            }));
        }
        this.bus.emit('mongosh:interrupt-complete');
        const { repl } = this.runtimeState();
        if (repl) {
            repl.setPrompt(await this.getShellPrompt());
        }
        return true;
    }
    writer(result) {
        var _a;
        if (isErrorLike(result)) {
            const output = {
                ...result,
                message: result.message || result.errmsg,
                name: result.name || 'MongoshInternalError',
                stack: result.stack,
                cause: result.cause,
            };
            this.bus.emit('mongosh:error', output, 'repl');
            return this.formatError(output);
        }
        return this.formatShellResult((_a = this.rawValueToShellResult.get(result)) !== null && _a !== void 0 ? _a : {
            type: null,
            printable: result,
        });
    }
    formatShellResult(result, extraFormatOptions = {}) {
        return this.formatOutput({ type: result.type, value: result.printable }, extraFormatOptions);
    }
    onPrint(values, type) {
        const extraOptions = type === 'printjson'
            ? {
                compact: false,
                depth: Infinity,
                maxArrayLength: Infinity,
                maxStringLength: Infinity,
            }
            : undefined;
        const joined = values
            .map((value) => this.formatShellResult(value, extraOptions))
            .join(' ');
        this.output.write(joined + '\n');
    }
    async onPrompt(question, type) {
        var _a;
        await enterAsynchronousExecutionForPrompt();
        if (type === 'password') {
            const passwordPromise = (0, askpassword_1.default)({
                input: this.input,
                output: this.output,
                replacementCharacter: '*',
            });
            this.output.write(question + '\n');
            return (await passwordPromise).toString();
        }
        else if (type === 'yesno') {
            let result = '';
            while (true) {
                const charPromise = (0, askcharacter_1.default)({
                    input: this.input,
                    output: this.output,
                });
                this.output.write(question + ': ');
                result = await charPromise;
                if (result.length > 0 && !/^[yYnN\r\n]$/.exec(result)) {
                    this.output.write('\nPlease enter Y or N: ');
                }
                else {
                    break;
                }
            }
            this.output.write('\n');
            return (_a = { Y: 'yes', N: 'no' }[result.toUpperCase()]) !== null && _a !== void 0 ? _a : '';
        }
        throw new Error(`Unrecognized prompt type ${type}`);
    }
    formatOutput(value, extraFormatOptions = {}) {
        return (0, format_output_1.default)(value, {
            ...this.getFormatOptions(),
            ...extraFormatOptions,
        });
    }
    formatError(value) {
        return (0, format_output_1.formatError)(value, this.getFormatOptions());
    }
    clr(text, style) {
        return (0, clr_1.default)(text, style, this.getFormatOptions());
    }
    getFormatOptions() {
        var _a, _b, _c, _d, _e, _f, _g;
        const output = this.output;
        return {
            colors: (_c = (_b = (_a = this._runtimeState) === null || _a === void 0 ? void 0 : _a.repl) === null || _b === void 0 ? void 0 : _b.useColors) !== null && _c !== void 0 ? _c : !!(output.isTTY && ((_e = (_d = output === null || output === void 0 ? void 0 : output.getColorDepth) === null || _d === void 0 ? void 0 : _d.call(output)) !== null && _e !== void 0 ? _e : 0) > 1),
            compact: this.inspectCompact,
            depth: this.inspectDepth,
            showStackTraces: this.showStackTraces,
            bugReportErrorMessageInfo: (_g = (_f = this.ioProvider).bugReportErrorMessageInfo) === null || _g === void 0 ? void 0 : _g.call(_f),
        };
    }
    runtimeState() {
        if (this._runtimeState === null) {
            throw new errors_1.MongoshInternalError('Mongosh not initialized yet');
        }
        return this._runtimeState;
    }
    async close() {
        var _a;
        const rs = this._runtimeState;
        if (rs) {
            this._runtimeState = null;
            (_a = rs.repl) === null || _a === void 0 ? void 0 : _a.close();
            await rs.instanceState.close(true);
            await new Promise((resolve) => this.output.write('', resolve));
        }
    }
    async onExit(exitCode) {
        await this.close();
        return this.ioProvider.exit(exitCode);
    }
    async getConfig(key) {
        return this.ioProvider.getConfig(key);
    }
    async setConfig(key, value) {
        const result = await this.ioProvider.setConfig(key, value);
        if (result === 'success') {
            if (key === 'historyLength' && this._runtimeState) {
                this.runtimeState().repl.historySize = value;
            }
            if (key === 'inspectCompact') {
                this.inspectCompact = value;
            }
            if (key === 'inspectDepth') {
                this.inspectDepth = value;
            }
            if (key === 'showStackTraces') {
                this.showStackTraces = value;
            }
            if (key === 'redactHistory') {
                this.redactHistory = value;
            }
        }
        return result;
    }
    async resetConfig(key) {
        return await this.setConfig(key, new types_1.CliUserConfig()[key]);
    }
    async validateConfig(key, value) {
        return types_1.CliUserConfigValidator.validate(key, value);
    }
    listConfigOptions() {
        return this.ioProvider.listConfigOptions();
    }
    async getCryptLibraryOptions() {
        return this.ioProvider.getCryptLibraryOptions();
    }
    async getShellPrompt() {
        const { context, instanceState } = this.runtimeState();
        try {
            this.insideAutoCompleteOrGetPrompt = true;
            if (typeof context.prompt !== 'undefined') {
                const promptResult = await this.loadExternalCode(`
        (() => {
          switch (typeof prompt) {
            case 'function':
              return prompt();
            case 'string':
              return prompt;
          }
        })()`, '<prompt loader>');
                if (typeof promptResult === 'string') {
                    return promptResult;
                }
            }
        }
        catch (_a) {
        }
        finally {
            this.insideAutoCompleteOrGetPrompt = false;
        }
        try {
            return await instanceState.getDefaultPrompt();
        }
        catch (_b) {
        }
        return '> ';
    }
    jsContext() {
        return this.runtimeState().repl ? 'repl' : 'plain-vm';
    }
}
function isErrorLike(value) {
    try {
        return (value &&
            (0, shell_api_1.getShellApiType)(value) === null &&
            ((value.message !== undefined && typeof value.stack === 'string') ||
                (value.code !== undefined && value.errmsg !== undefined)));
    }
    catch (err) {
        throw new errors_1.MongoshInternalError((err === null || err === void 0 ? void 0 : err.message) || String(err));
    }
}
async function enterAsynchronousExecutionForPrompt() {
    await new Promise(setImmediate);
}
exports.default = MongoshNodeRepl;
//# sourceMappingURL=mongosh-repl.js.map