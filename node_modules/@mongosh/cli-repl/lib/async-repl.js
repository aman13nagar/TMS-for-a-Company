"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = exports.evalFinish = exports.evalStart = void 0;
const is_recoverable_error_1 = __importDefault(require("is-recoverable-error"));
const util_1 = require("util");
exports.evalStart = Symbol('async-repl:evalStart');
exports.evalFinish = Symbol('async-repl:evalFinish');
function disableEvent(emitter, event) {
    const rawListeners = emitter.rawListeners(event);
    emitter.removeAllListeners(event);
    return {
        restore() {
            for (const listener of rawListeners) {
                emitter.on(event, listener);
            }
        },
    };
}
function getPrompt(repl) {
    var _a, _b;
    return (_b = (_a = repl.getPrompt) === null || _a === void 0 ? void 0 : _a.call(repl)) !== null && _b !== void 0 ? _b : repl._prompt;
}
function start(opts) {
    var _a;
    const { Recoverable, start: originalStart } = require('repl');
    const { asyncEval, wrapCallbackError = (err) => err, onAsyncSigint } = opts;
    if (onAsyncSigint) {
        opts.breakEvalOnSigint = true;
    }
    const repl = ((_a = opts.start) !== null && _a !== void 0 ? _a : originalStart)(opts);
    const originalEval = (0, util_1.promisify)(wrapPauseInput(repl.input, wrapNoSyncDomainError(repl.eval.bind(repl))));
    const setRawMode = (mode) => {
        const input = repl.input;
        const wasInRawMode = input.isRaw;
        if (typeof input.setRawMode === 'function') {
            input.setRawMode(mode);
        }
        return wasInRawMode;
    };
    repl.eval = (input, context, filename, callback) => {
        async function _eval() {
            var _a, _b;
            let previouslyInRawMode;
            if (onAsyncSigint) {
                previouslyInRawMode = setRawMode(false);
            }
            let result;
            repl.emit(exports.evalStart, { input });
            const origPrompt = getPrompt(repl);
            const { Interface } = require('readline');
            Interface.prototype.setPrompt.call(repl, '');
            try {
                let exitEventPending = false;
                const exitListener = () => {
                    exitEventPending = true;
                };
                let previousExitListeners = [];
                let sigintListener = undefined;
                let replSigint = undefined;
                let processSigint = undefined;
                try {
                    result = await new Promise((resolve, reject) => {
                        if (onAsyncSigint) {
                            sigintListener = async () => {
                                let interruptHandled = false;
                                try {
                                    interruptHandled = await onAsyncSigint();
                                }
                                catch (e) {
                                }
                                finally {
                                    reject(interruptHandled
                                        ? undefined
                                        : new Error('Asynchronous execution was interrupted by `SIGINT`'));
                                }
                            };
                            replSigint = disableEvent(repl, 'SIGINT');
                            processSigint = disableEvent(process, 'SIGINT');
                            repl.once('SIGINT', sigintListener);
                        }
                        previousExitListeners = repl.rawListeners('exit');
                        repl.removeAllListeners('exit');
                        repl.once('exit', exitListener);
                        const evalResult = asyncEval(originalEval, input, context, filename);
                        if (sigintListener !== undefined) {
                            process.once('SIGINT', sigintListener);
                        }
                        evalResult.then(resolve, reject);
                    });
                }
                finally {
                    if (typeof previouslyInRawMode !== 'undefined') {
                        setRawMode(previouslyInRawMode);
                    }
                    if (sigintListener !== undefined) {
                        repl.removeListener('SIGINT', sigintListener);
                        process.removeListener('SIGINT', sigintListener);
                    }
                    (_a = replSigint === null || replSigint === void 0 ? void 0 : replSigint.restore) === null || _a === void 0 ? void 0 : _a.call(replSigint);
                    (_b = processSigint === null || processSigint === void 0 ? void 0 : processSigint.restore) === null || _b === void 0 ? void 0 : _b.call(processSigint);
                    if (getPrompt(repl) === '') {
                        Interface.prototype.setPrompt.call(repl, origPrompt);
                    }
                    repl.removeListener('exit', exitListener);
                    for (const listener of previousExitListeners) {
                        repl.on('exit', listener);
                    }
                    if (exitEventPending) {
                        process.nextTick(() => repl.emit('exit'));
                    }
                }
            }
            catch (err) {
                try {
                    if ((0, is_recoverable_error_1.default)(input)) {
                        repl.emit(exports.evalFinish, {
                            input,
                            success: false,
                            err,
                            recoverable: true,
                        });
                        return callback(new Recoverable(err));
                    }
                    repl.emit(exports.evalFinish, {
                        input,
                        success: false,
                        err,
                        recoverable: false,
                    });
                    return callback(err);
                }
                catch (callbackErr) {
                    return callback(wrapCallbackError(callbackErr));
                }
            }
            try {
                repl.emit(exports.evalFinish, { input, success: true });
                return callback(null, result);
            }
            catch (callbackErr) {
                return callback(wrapCallbackError(callbackErr));
            }
        }
        _eval().catch((e) => callback(e));
    };
    return repl;
}
exports.start = start;
function wrapNoSyncDomainError(fn) {
    return (...args) => {
        const { Domain } = require('domain');
        const origEmit = Domain.prototype.emit;
        Domain.prototype.emit = function (ev, ...eventArgs) {
            if (ev === 'error') {
                this.exit();
                throw eventArgs[0];
            }
            return origEmit.call(this, ev, ...eventArgs);
        };
        try {
            return fn(...args);
        }
        finally {
            Domain.prototype.emit = origEmit;
        }
    };
}
function wrapPauseInput(input, fn) {
    return (...args) => {
        const wasReadingAndNeedToWorkaroundWindowsBug = process.platform === 'win32' &&
            input.isTTY &&
            input._handle &&
            input._handle.reading &&
            typeof input._handle.readStop === 'function' &&
            typeof input._handle.readStart === 'function';
        if (wasReadingAndNeedToWorkaroundWindowsBug) {
            input._handle.reading = false;
            input._handle.readStop();
        }
        try {
            return fn(...args);
        }
        finally {
            if (wasReadingAndNeedToWorkaroundWindowsBug && !input._handle.reading) {
                input._handle.reading = true;
                input._handle.readStart();
            }
        }
    };
}
//# sourceMappingURL=async-repl.js.map