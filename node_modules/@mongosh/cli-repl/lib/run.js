"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
let fipsError;
function enableFipsIfRequested() {
    if (process.argv.includes('--tlsFIPSMode')) {
        try {
            require('crypto').setFips(1);
        }
        catch (err) {
            fipsError !== null && fipsError !== void 0 ? fipsError : (fipsError = err);
        }
    }
}
enableFipsIfRequested();
const startup_timing_1 = require("./startup-timing");
const cli_repl_1 = require("./cli-repl");
const arg_parser_1 = require("./arg-parser");
const smoke_tests_1 = require("./smoke-tests");
const constants_1 = require("./constants");
const build_info_1 = require("./build-info");
const config_directory_1 = require("./config-directory");
const crypt_library_paths_1 = require("./crypt-library-paths");
const tls_certificate_selector_1 = require("./tls-certificate-selector");
const history_1 = require("@mongosh/history");
const arg_parser_2 = require("@mongosh/arg-parser");
const askcharacter_1 = __importDefault(require("askcharacter"));
const stream_1 = require("stream");
const crypto_1 = __importDefault(require("crypto"));
const net_1 = __importDefault(require("net"));
const v8_1 = __importDefault(require("v8"));
const types_1 = require("@mongosh/types");
require("./webpack-self-inspection");
if ((_b = (_a = v8_1.default === null || v8_1.default === void 0 ? void 0 : v8_1.default.startupSnapshot) === null || _a === void 0 ? void 0 : _a.isBuildingSnapshot) === null || _b === void 0 ? void 0 : _b.call(_a)) {
    require('@mongodb-js/saslprep');
    require('socks');
    require('emphasize');
    require('ipv6-normalize');
    require('bindings');
    {
        const console = require('console');
        const ConsoleCtor = console.Console;
        v8_1.default.startupSnapshot.addDeserializeCallback(() => {
            console.Console = ConsoleCtor;
            process.chdir('.');
        });
    }
    v8_1.default.startupSnapshot.setDeserializeMainFunction(() => {
        enableFipsIfRequested();
        (0, startup_timing_1.markTime)(types_1.TimingCategories.Snapshot, 'loaded pre-snapshot deps');
        void main();
    });
}
else {
    void main();
}
async function main() {
    var _a;
    (0, startup_timing_1.markTime)(types_1.TimingCategories.Main, 'entered main');
    if (process.env.MONGOSH_RUN_NODE_SCRIPT) {
        process.argv.splice(1, 1);
        require('module').runMain(process.argv[1]);
        return;
    }
    let repl;
    let isSingleConsoleProcess = false;
    try {
        (_a = net_1.default === null || net_1.default === void 0 ? void 0 : net_1.default.setDefaultAutoSelectFamily) === null || _a === void 0 ? void 0 : _a.call(net_1.default, true);
        const options = (0, arg_parser_1.parseCliArgs)(process.argv);
        for (const warning of options._argParseWarnings) {
            console.warn(warning);
        }
        const { version } = require('../package.json');
        if (options.tlsFIPSMode) {
            if (!fipsError && !crypto_1.default.getFips()) {
                fipsError = new Error('FIPS mode not enabled despite requested');
            }
            if (fipsError) {
                if (process.config.variables.node_shared_openssl) {
                    console.error('Could not enable FIPS mode. Please ensure that your system OpenSSL installation');
                    console.error('supports FIPS, and see the mongosh FIPS documentation for more information.');
                }
                else {
                    console.error('Could not enable FIPS mode. This mongosh installation does not appear to');
                    console.error('support FIPS. Please see the mongosh FIPS documentation for more information.');
                }
                console.error('Error details:');
                console.error(fipsError);
                process.exit(1);
            }
        }
        if (options.help) {
            console.log(constants_1.USAGE);
            return;
        }
        if (options.version) {
            console.log((0, build_info_1.baseBuildInfo)().version);
            return;
        }
        if (options.buildInfo) {
            console.log(JSON.stringify(await (0, build_info_1.buildInfo)(), null, '  '));
            return;
        }
        if (options.smokeTests || options.perfTests) {
            const smokeTestServer = process.env.MONGOSH_SMOKE_TEST_SERVER;
            const cryptLibraryOpts = options.cryptSharedLibPath
                ? [`--cryptSharedLibPath=${options.cryptSharedLibPath}`]
                : [];
            if (process.execPath === process.argv[1]) {
                await (0, smoke_tests_1.runSmokeTests)({
                    smokeTestServer,
                    args: [process.execPath, ...cryptLibraryOpts],
                    wantPerformanceTesting: !!options.perfTests,
                });
            }
            else {
                await (0, smoke_tests_1.runSmokeTests)({
                    smokeTestServer,
                    args: [process.execPath, process.argv[1], ...cryptLibraryOpts],
                    wantPerformanceTesting: !!options.perfTests,
                });
            }
            return;
        }
        if (process.execPath === process.argv[1]) {
            process.removeAllListeners('warning');
        }
        if (process.env.CLEAR_SIGINT_LISTENERS) {
            process.removeAllListeners('SIGINT');
        }
        isSingleConsoleProcess =
            !!process.env.MONGOSH_FORCE_CONNECTION_STRING_PROMPT;
        if ((!options.connectionSpecifier &&
            process.platform === 'win32' &&
            process.stdin.isTTY &&
            process.stdout.isTTY) ||
            isSingleConsoleProcess) {
            try {
                isSingleConsoleProcess || (isSingleConsoleProcess = require('get-console-process-list')().length === 1);
            }
            catch (_b) {
            }
            if (isSingleConsoleProcess) {
                const result = await ask('Please enter a MongoDB connection string (Default: mongodb://localhost/): ');
                if (result.trim() !== '') {
                    options.connectionSpecifier = result.trim();
                }
            }
        }
        const connectionInfo = (0, arg_parser_2.generateConnectionInfoFromCliArgs)(options);
        connectionInfo.driverOptions = {
            ...connectionInfo.driverOptions,
            ...(0, tls_certificate_selector_1.getTlsCertificateSelector)(options.tlsCertificateSelector),
            driverInfo: { name: 'mongosh', version },
        };
        const title = `mongosh ${(0, history_1.redactURICredentials)(connectionInfo.connectionString)}`;
        process.title = title;
        setTerminalWindowTitle(title);
        const shellHomePaths = (0, config_directory_1.getStoragePaths)();
        const globalConfigPaths = (0, config_directory_1.getGlobalConfigPaths)();
        repl = new cli_repl_1.CliRepl({
            shellCliOptions: {
                ...options,
            },
            getCryptLibraryPaths: crypt_library_paths_1.getCryptLibraryPaths,
            input: process.stdin,
            output: process.stdout,
            onExit: (code) => code === undefined ? process.exit() : process.exit(code),
            shellHomePaths: shellHomePaths,
            globalConfigPaths: globalConfigPaths,
        });
        (0, startup_timing_1.markTime)(types_1.TimingCategories.REPLInstantiation, 'entering repl.start()');
        await repl.start(connectionInfo.connectionString, {
            productName: 'MongoDB Shell',
            productDocsLink: 'https://www.mongodb.com/docs/mongodb-shell/',
            ...connectionInfo.driverOptions,
        });
    }
    catch (e) {
        if (process.env.MONGOSH_DISPLAY_STARTUP_STACK_TRACE)
            console.error(e === null || e === void 0 ? void 0 : e.stack);
        else
            console.error(`${e === null || e === void 0 ? void 0 : e.name}: ${e === null || e === void 0 ? void 0 : e.message}`);
        if (repl !== undefined) {
            repl.bus.emit('mongosh:error', e, 'startup');
        }
        if (isSingleConsoleProcess) {
            process.stdout.write('Press any key to exit: ');
            await (0, askcharacter_1.default)({ input: process.stdin, output: process.stdout });
            process.stdout.write('\n');
        }
        process.exit(1);
    }
}
function setTerminalWindowTitle(title) {
    var _a;
    if (!process.stdout.isTTY) {
        return;
    }
    const term = (_a = process.env.TERM) !== null && _a !== void 0 ? _a : '';
    if (/^(linux|xterm|rxvt)/.test(term)) {
        process.stdout.write(`\u001b]0;${title}\u0007`);
    }
    else if (/^screen/.test(term)) {
        process.stdout.write(`\u001bk${title}\u001b\\`);
    }
}
async function ask(prompt) {
    const stdinCopy = process.stdin.pipe(new stream_1.PassThrough());
    try {
        const { createInterface } = require('readline');
        const readlineInterface = createInterface({
            input: stdinCopy,
            output: process.stdout,
            prompt,
        });
        readlineInterface.prompt();
        for await (const line of readlineInterface) {
            return line;
        }
        return '';
    }
    finally {
        process.stdin.unpipe(stdinCopy);
    }
}
//# sourceMappingURL=run.js.map